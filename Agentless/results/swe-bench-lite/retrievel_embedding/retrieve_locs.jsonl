{"instance_id": "astropy__astropy-14995", "found_files": ["examples/template/example-template.py", "docs/nddata/examples/cutout2d_tofits.py", "examples/io/skip_create-large-fits.py", ".pyinstaller/run_astropy_tests.py", "docs/conf.py", "examples/coordinates/plot_sgr-coordinate-frame.py", "examples/coordinates/plot_obs-planning.py", "examples/io/split-jpeg-to-fits.py", "examples/coordinates/rv-to-gsr.py", "docs/wcs/examples/programmatic.py", "examples/coordinates/plot_galactocentric-frame.py", "examples/io/create-mef.py", "docs/wcs/examples/from_file.py", "examples/io/modify-fits-header.py", "docs/wcs/examples/cube_wcs.py", "examples/io/fits-tables.py", "examples/io/plot_fits-image.py", "docs/conftest.py", ".pyinstaller/hooks/hook-skyfield.py"], "node_info": [{"code": "\"\"\"\n\n##############################################################################\n# Make print work the same in all versions of Python, set up numpy,\n# matplotlib, and use a nicer set of plot parameters:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom astropy.visualization import astropy_mpl_style\n\nplt.style.use(astropy_mpl_style)\n# uncomment if including figures:\n# import matplotlib.pyplot as plt\n# from astropy.visualization import astropy_mpl_style\n# plt.style.use(astropy_mpl_style)\n\n##############################################################################\n# This code block is executed, although it produces no output. Lines starting\n# with a simple hash are code comment and get treated as part of the code\n# block. To include this new comment string we started the new block with a\n# long line of hashes.\n#\n# The sphinx-gallery parser will assume everything after this splitter and that\n# continues to start with a **comment hash and space** (respecting code style)\n# is text that has to be rendered in\n# html format. Keep in mind to always keep your comments always together by\n# comment hashes. That means to break a paragraph you still need to comment\n# that line break.\n#\n# In this example the next block of code produces some plotable data. Code is\n# executed, figure is saved and then code is presented next, followed by the\n# inlined figure.\n\nx = np.linspace(-np.pi, np.pi, 300)\nxx, yy = np.meshgrid(x, x)\nz = np.cos(xx) + np.cos(yy)\n\nplt.figure()\nplt.imshow(z)\nplt.colorbar()\nplt.xlabel('$x$')\nplt.ylabel('$y$')\n\n###########################################################################\n# Again it is possible to continue the discussion with a new Python string. This\n# time to introduce the next code block generates 2 separate figures.\n\nplt.figure()\nplt.imshow(z, cmap=plt.cm.get_cmap('hot'))\nplt.figure()\nplt.imshow(z, cmap=plt.cm.get_cmap('Spectral'), interpolation='none')\n\n##########################################################################\n# There's some subtle differences between rendered html rendered comment\n# strings and code comment strings which I'll demonstrate below. (Some of this\n# only makes sense if you look at the\n# :download:`raw Python script <plot_notebook.py>`)\n#\n# Comments in comment blocks remain nested in the text.\n\n\ndef dummy():\n    \"\"\"Dummy function to make sure docstrings don't get rendered as text\"\"\"\n    pass", "metadata": {"file_name": "examples/template/example-template.py", "File Name": "examples/template/example-template.py", "Functions": "dummy"}}, {"code": "# Download an example FITS file, create a 2D cutout, and save it to a\n# new FITS file, including the updated cutout WCS.\nfrom astropy.io import fits\nfrom astropy.nddata import Cutout2D\nfrom astropy.utils.data import download_file\nfrom astropy.wcs import WCS\n\n\ndef download_image_save_cutout(url, position, size):\n    # Download the image\n    filename = download_file(url)\n\n    # Load the image and the WCS\n    hdu = fits.open(filename)[0]\n    wcs = WCS(hdu.header)\n\n    # Make the cutout, including the WCS\n    cutout = Cutout2D(hdu.data, position=position, size=size, wcs=wcs)\n\n    # Put the cutout image in the FITS HDU\n    hdu.data = cutout.data\n\n    # Update the FITS header with the cutout WCS\n    hdu.header.update(cutout.wcs.to_header())\n\n    # Write the cutout to a new FITS file\n    cutout_filename = 'example_cutout.fits'\n    hdu.writeto(cutout_filename, overwrite=True)\n\n\nif __name__ == '__main__':\n    url = 'https://astropy.stsci.edu/data/photometry/spitzer_example_image.fits'\n\n    position = (500, 300)\n    size = (400, 400)\n    download_image_save_cutout(url, position, size)", "metadata": {"file_name": "docs/nddata/examples/cutout2d_tofits.py", "File Name": "docs/nddata/examples/cutout2d_tofits.py", "Functions": "download_image_save_cutout"}}, {"code": "abs(header['BITPIX'])/8\n    # (this example is assuming a 64-bit float)\n    # The -1 is to account for the final byte that we are about to\n    # write:\n    fobj.seek(len(header.tostring()) + (40000 * 40000 * 8) - 1)\n    fobj.write(b'\\0')\n\n##############################################################################\n# More generally, this can be written:\n\nshape = tuple(header[f'NAXIS{ii}'] for ii in range(1, header['NAXIS']+1))\nwith open('large.fits', 'rb+') as fobj:\n    fobj.seek(len(header.tostring()) + (np.prod(shape) * np.abs(header['BITPIX']//8)) - 1)\n    fobj.write(b'\\0')\n\n##############################################################################\n# On modern operating systems this will cause the file (past the header) to be\n# filled with zeros out to the ~12GB needed to hold a 40000 x 40000 image. On\n# filesystems that support sparse file creation (most Linux filesystems, but not\n# the HFS+ filesystem used by most Macs) this is a very fast, efficient\n# operation. On other systems your mileage may vary.\n#\n# This isn't the only way to build up a large file, but probably one of the\n# safest. This method can also be used to create large multi-extension FITS\n# files, with a little care.\n\n##############################################################################\n# Finally, we'll remove the file we created:\n\nos.remove('large.fits')", "metadata": {"file_name": "examples/io/skip_create-large-fits.py", "File Name": "examples/io/skip_create-large-fits.py"}}, {"code": "os.remove(os.path.join(\"astropy_tests\", \"table\", \"mixins\", \"tests\", \"test_registry.py\"))\n\n# Copy the top-level conftest.py\nshutil.copy2(\n    os.path.join(ROOT, \"astropy\", \"conftest.py\"),\n    os.path.join(\"astropy_tests\", \"conftest.py\"),\n)\n\n# matplotlib hook in pyinstaller 5.0 and later no longer collects every backend, see\n# https://github.com/pyinstaller/pyinstaller/issues/6760\nmatplotlib.use(\"svg\")\n\n# We skip a few tests, which are generally ones that rely on explicitly\n# checking the name of the current module (which ends up starting with\n# astropy_tests rather than astropy).\n\nSKIP_TESTS = [\n    \"test_exception_logging_origin\",\n    \"test_log\",\n    \"test_configitem\",\n    \"test_config_noastropy_fallback\",\n    \"test_no_home\",\n    \"test_path\",\n    \"test_rename_path\",\n    \"test_data_name_third_party_package\",\n    \"test_pkg_finder\",\n    \"test_wcsapi_extension\",\n    \"test_find_current_module_bundle\",\n    \"test_minversion\",\n    \"test_imports\",\n    \"test_generate_config\",\n    \"test_generate_config2\",\n    \"test_create_config_file\",\n    \"test_download_parallel_fills_cache\",\n]\n\n# Run the tests!\nsys.exit(\n    pytest.main(\n        [\"astropy_tests\", \"-k \" + \" and \".join(\"not \" + test for test in SKIP_TESTS)],\n        plugins=[\n            \"pytest_astropy.plugin\",\n            \"pytest_doctestplus.plugin\",\n            \"pytest_remotedata.plugin\",\n            \"pytest_astropy_header.display\",\n        ],\n    )\n)", "metadata": {"file_name": ".pyinstaller/run_astropy_tests.py", "File Name": ".pyinstaller/run_astropy_tests.py"}}, {"code": "# so here we mostly need to define Astropy-specific x-refs\nnumpydoc_xref_aliases.update(\n    {\n        # python & adjacent\n        \"Any\": \"`~typing.Any`\",\n        \"file-like\": \":term:`python:file-like object`\",\n        \"file\": \":term:`python:file object`\",\n        \"path-like\": \":term:`python:path-like object`\",\n        \"module\": \":term:`python:module`\",\n        \"buffer-like\": \":term:buffer-like\",\n        \"hashable\": \":term:`python:hashable`\",\n        # for matplotlib\n        \"color\": \":term:`color`\",\n        # for numpy\n        \"ints\": \":class:`python:int`\",\n        # for astropy\n        \"number\": \":term:`number`\",\n        \"Representation\": \":class:`~astropy.coordinates.BaseRepresentation`\",\n        \"writable\": \":term:`writable file-like object`\",\n        \"readable\": \":term:`readable file-like object`\",\n        \"BaseHDU\": \":doc:`HDU </io/fits/api/hdus>`\",\n    }\n)\n# Add from sphinx-astropy 1) glossary aliases 2) physical types.\nnumpydoc_xref_aliases.update(numpydoc_xref_astropy_aliases)\n\n# Turn off table of contents entries for functions and classes\ntoc_object_entries = False\n\n# -- Project information ------------------------------------------------------\n\nproject = \"Astropy\"\nauthor = \"The Astropy Developers\"\ncopyright = f\"2011\u2013{datetime.utcnow().year}, \" + author\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n\n# The full version, including alpha/beta/rc tags.\nrelease = metadata.version(project)\n# The short X.Y version.\nversion = \".\".join(release.split(\".\")[:2])\n\n# Only include dev docs in dev version.\ndev = \"dev\" in release\nif not dev:\n    exclude_patterns += [\"development/*\", \"testhelpers.rst\"]\n\n# -- Options for the module index ---------------------------------------------\n\nmodindex_common_prefix = [\"astropy.\"]", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "import os\nimport shutil\nimport sys\n\nimport erfa  # noqa: F401\nimport matplotlib\nimport pytest\n\nimport astropy  # noqa: F401\n\nif len(sys.argv) == 3 and sys.argv[1] == \"--astropy-root\":\n    ROOT = sys.argv[2]\nelse:\n    # Make sure we don't allow any arguments to be passed - some tests call\n    # sys.executable which becomes this script when producing a pyinstaller\n    # bundle, but we should just error in this case since this is not the\n    # regular Python interpreter.\n    if len(sys.argv) > 1:\n        print(\"Extra arguments passed, exiting early\")\n        sys.exit(1)\n\nfor root, dirnames, files in os.walk(os.path.join(ROOT, \"astropy\")):\n    # NOTE: we can't simply use\n    # test_root = root.replace('astropy', 'astropy_tests')\n    # as we only want to change the one which is for the module, so instead\n    # we search for the last occurrence and replace that.\n    pos = root.rfind(\"astropy\")\n    test_root = root[:pos] + \"astropy_tests\" + root[pos + 7 :]\n\n    # Copy over the astropy 'tests' directories and their contents\n    for dirname in dirnames:\n        final_dir = os.path.relpath(os.path.join(test_root, dirname), ROOT)\n        # We only copy over 'tests' directories, but not astropy/tests (only\n        # astropy/tests/tests) since that is not just a directory with tests.\n        if dirname == \"tests\" and not root.endswith(\"astropy\"):\n            shutil.copytree(os.path.join(root, dirname), final_dir, dirs_exist_ok=True)\n        else:\n            # Create empty __init__.py files so that 'astropy_tests' still\n            # behaves like a single package, otherwise pytest gets confused\n            # by the different conftest.py files.", "metadata": {"file_name": ".pyinstaller/run_astropy_tests.py", "File Name": ".pyinstaller/run_astropy_tests.py"}}, {"code": "##############################################################################\n# The decorator ``@frame_transform_graph.transform(coord.StaticMatrixTransform,\n# coord.Galactic, Sagittarius)``  registers this function on the\n# ``frame_transform_graph`` as a coordinate transformation. Inside the function,\n# we simply return the previously defined rotation matrix.\n#\n# We then register the inverse transformation by using the transpose of the\n# rotation matrix (which is faster to compute than the inverse):\n\n@frame_transform_graph.transform(coord.StaticMatrixTransform, Sagittarius, coord.Galactic)\ndef sgr_to_galactic():\n    \"\"\"Compute the heliocentric Sgr to spherical Galactic transformation matrix.\"\"\"\n    return matrix_transpose(SGR_MATRIX)\n\n\n##############################################################################\n# Now that we've registered these transformations between ``Sagittarius`` and\n# `~astropy.coordinates.Galactic`, we can transform between *any* coordinate\n# system and ``Sagittarius`` (as long as the other system has a path to\n# transform to `~astropy.coordinates.Galactic`). For example, to transform from\n# ICRS coordinates to ``Sagittarius``, we would do:\n\nicrs = coord.SkyCoord(280.161732*u.degree, 11.91934*u.degree, frame='icrs')\nsgr = icrs.transform_to(Sagittarius)\nprint(sgr)\n\n##############################################################################\n# Or, to transform from the ``Sagittarius`` frame to ICRS coordinates (in this\n# case, a line along the ``Sagittarius`` x-y plane):\n\nsgr = coord.SkyCoord(Lambda=np.linspace(0, 2*np.pi, 128)*u.radian,\n                     Beta=np.zeros(128)*u.radian, frame='sagittarius')\nicrs = sgr.transform_to(coord.ICRS)\nprint(icrs)\n\n##############################################################################\n# As an example, we'll now plot the points in both coordinate systems:\n\nfig, axes = plt.subplots(2, 1, figsize=(8, 10),\n                         subplot_kw={'projection': 'aitoff'})\n\naxes[0].set_title(\"Sagittarius\")\naxes[0].plot(sgr.Lambda.wrap_at(180*u.deg).radian, sgr.Beta.radian,\n             linestyle='none', marker='.')", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "#\n# Create a stub array to initialize the HDU; its\n# exact size is irrelevant, as long as it has the desired number of\n# dimensions\n\ndata = np.zeros((100, 100), dtype=np.float64)\nhdu = fits.PrimaryHDU(data=data)\nheader = hdu.header\nwhile len(header) < (36 * 4 - 1):\n    header.append()  # Adds a blank card to the end\n\n##############################################################################\n# Now adjust the NAXISn keywords to the desired size of the array, and write\n# only the header out to a file. Using the ``hdu.writeto()`` method will cause\n# astropy to \"helpfully\" reset the NAXISn keywords to match the size of the\n# dummy array. That is because it works hard to ensure that only valid FITS\n# files are written. Instead, we can write just the header to a file using the\n# `astropy.io.fits.Header.tofile` method:\n\nheader['NAXIS1'] = 40000\nheader['NAXIS2'] = 40000\nheader.tofile('large.fits')\n\n##############################################################################\n# Finally, grow out the end of the file to match the length of the\n# data (plus the length of the header). This can be done very efficiently on\n# most systems by seeking past the end of the file and writing a single byte,\n# like so:\n\nwith open('large.fits', 'rb+') as fobj:\n    # Seek past the length of the header, plus the length of the\n    # Data we want to write.\n    # 8 is the number of bytes per value, i.e.", "metadata": {"file_name": "examples/io/skip_create-large-fits.py", "File Name": "examples/io/skip_create-large-fits.py"}}, {"code": "#\n# Find the alt,az coordinates of M33 at 100 times evenly spaced between 10pm\n# and 7am EDT:\n\nmidnight = Time('2012-7-13 00:00:00') - utcoffset\ndelta_midnight = np.linspace(-2, 10, 100)*u.hour\nframe_July13night = AltAz(obstime=midnight+delta_midnight,\n                          location=bear_mountain)\nm33altazs_July13night = m33.transform_to(frame_July13night)\n\n##############################################################################\n# convert alt, az to airmass with `~astropy.coordinates.AltAz.secz` attribute:\n\nm33airmasss_July13night = m33altazs_July13night.secz\n\n##############################################################################\n# Plot the airmass as a function of time:\n\nplt.plot(delta_midnight, m33airmasss_July13night)\nplt.xlim(-2, 10)\nplt.ylim(1, 4)\nplt.xlabel('Hours from EDT Midnight')\nplt.ylabel('Airmass [Sec(z)]')\nplt.show()\n\n##############################################################################\n# Use  `~astropy.coordinates.get_sun` to find the location of the Sun at 1000\n# evenly spaced times between noon on July 12 and noon on July 13:\n\nfrom astropy.coordinates import get_sun\n\ndelta_midnight = np.linspace(-12, 12, 1000)*u.hour\ntimes_July12_to_13 = midnight + delta_midnight\nframe_July12_to_13 = AltAz(obstime=times_July12_to_13, location=bear_mountain)\nsunaltazs_July12_to_13 = get_sun(times_July12_to_13).transform_to(frame_July12_to_13)", "metadata": {"file_name": "examples/coordinates/plot_obs-planning.py", "File Name": "examples/coordinates/plot_obs-planning.py"}}, {"code": "with open(\"common_links.txt\") as cl:\n    rst_epilog += cl.read().format(\n        minimum_python=__minimum_python_version__, **min_versions\n    )\n\n# Manually register doctest options since matplotlib 3.5 messed up allowing them\n# from pytest-doctestplus\nIGNORE_OUTPUT = doctest.register_optionflag(\"IGNORE_OUTPUT\")\nREMOTE_DATA = doctest.register_optionflag(\"REMOTE_DATA\")\nFLOAT_CMP = doctest.register_optionflag(\"FLOAT_CMP\")\n\n# Whether to create cross-references for the parameter types in the\n# Parameters, Other Parameters, Returns and Yields sections of the docstring.\nnumpydoc_xref_param_type = True\n\n# Words not to cross-reference. Most likely, these are common words used in\n# parameter type descriptions that may be confused for classes of the same\n# name. The base set comes from sphinx-astropy. We add more here.\nnumpydoc_xref_ignore.update(\n    {\n        \"mixin\",\n        \"Any\",  # aka something that would be annotated with `typing.Any`\n        # needed in subclassing numpy  # TODO! revisit\n        \"Arguments\",\n        \"Path\",\n        # TODO! not need to ignore.\n        \"flag\",\n        \"bits\",\n    }\n)\n\n# Mappings to fully qualified paths (or correct ReST references) for the\n# aliases/shortcuts used when specifying the types of parameters.\n# Numpy provides some defaults\n# https://github.com/numpy/numpydoc/blob/b352cd7635f2ea7748722f410a31f937d92545cc/numpydoc/xref.py#L62-L94\n# and a base set comes from sphinx-astropy.", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "\"\"\"\n=====================================================\nConvert a 3-color image (JPG) to separate FITS images\n=====================================================\n\nThis example opens an RGB JPEG image and writes out each channel as a separate\nFITS (image) file.\n\nThis example uses `pillow <https://python-pillow.org>`_ to read the image,\n`matplotlib.pyplot` to display the image, and `astropy.io.fits` to save FITS files.\n\n\n*By: Erik Bray, Adrian Price-Whelan*\n\n*License: BSD*", "metadata": {"file_name": "examples/io/split-jpeg-to-fits.py", "File Name": "examples/io/split-jpeg-to-fits.py"}}, {"code": "\"\"\"\n\n##############################################################################\n# Make `print` work the same in all versions of Python, set up numpy,\n# matplotlib, and use a nicer set of plot parameters:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom astropy.visualization import astropy_mpl_style\n\nplt.style.use(astropy_mpl_style)\n\n\n##############################################################################\n# Import the packages necessary for coordinates\n\nimport astropy.coordinates as coord\nimport astropy.units as u\nfrom astropy.coordinates import frame_transform_graph\nfrom astropy.coordinates.matrix_utilities import matrix_transpose, rotation_matrix\n\n##############################################################################\n# The first step is to create a new class, which we'll call\n# ``Sagittarius`` and make it a subclass of\n# `~astropy.coordinates.BaseCoordinateFrame`:", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "axes[1].set_title(\"ICRS\")\naxes[1].plot(icrs.ra.wrap_at(180*u.deg).radian, icrs.dec.radian,\n             linestyle='none', marker='.')\n\nplt.show()\n\n##############################################################################\n# This particular transformation is just a spherical rotation, which is a\n# special case of an Affine transformation with no vector offset. The\n# transformation of velocity components is therefore natively supported as\n# well:\n\nsgr = coord.SkyCoord(Lambda=np.linspace(0, 2*np.pi, 128)*u.radian,\n                     Beta=np.zeros(128)*u.radian,\n                     pm_Lambda_cosBeta=np.random.uniform(-5, 5, 128)*u.mas/u.yr,\n                     pm_Beta=np.zeros(128)*u.mas/u.yr,\n                     frame='sagittarius')\nicrs = sgr.transform_to(coord.ICRS)\nprint(icrs)\n\nfig, axes = plt.subplots(3, 1, figsize=(8, 10), sharex=True)\n\naxes[0].set_title(\"Sagittarius\")\naxes[0].plot(sgr.Lambda.degree,\n             sgr.pm_Lambda_cosBeta.value,\n             linestyle='none', marker='.')\naxes[0].set_xlabel(r\"$\\Lambda$ [deg]\")\naxes[0].set_ylabel(\n    fr\"$\\mu_\\Lambda \\, \\cos B$ [{sgr.pm_Lambda_cosBeta.unit.to_string('latex_inline')}]\")\n\naxes[1].set_title(\"ICRS\")\naxes[1].plot(icrs.ra.degree, icrs.pm_ra_cosdec.value,\n             linestyle='none', marker='.')\naxes[1].set_ylabel(\n    fr\"$\\mu_\\alpha \\, \\cos\\delta$ [{icrs.pm_ra_cosdec.unit.to_string('latex_inline')}]\")\n\naxes[2].set_title(\"ICRS\")\naxes[2].plot(icrs.ra.degree, icrs.pm_dec.value,\n             linestyle='none', marker='.')\naxes[2].set_xlabel(\"RA [deg]\")\naxes[2].set_ylabel(\n    fr\"$\\mu_\\delta$ [{icrs.pm_dec.unit.to_string('latex_inline')}]\")\n\nplt.show()", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "################################################################################\n# We could wrap this in a function so we can control the solar velocity and\n# re-use the above code:\ndef rv_to_gsr(c, v_sun=None):\n    \"\"\"Transform a barycentric radial velocity to the Galactic Standard of Rest\n    (GSR).\n\n    The input radial velocity must be passed in as a\n\n    Parameters\n    ----------\n    c : `~astropy.coordinates.BaseCoordinateFrame` subclass instance\n        The radial velocity, associated with a sky coordinates, to be\n        transformed.\n    v_sun : `~astropy.units.Quantity`, optional\n        The 3D velocity of the solar system barycenter in the GSR frame.\n        Defaults to the same solar motion as in the\n        `~astropy.coordinates.Galactocentric` frame.\n\n    Returns\n    -------\n    v_gsr : `~astropy.units.Quantity`\n        The input radial velocity transformed to a GSR frame.\n\n    \"\"\"\n    if v_sun is None:\n        v_sun = coord.Galactocentric().galcen_v_sun.to_cartesian()\n\n    gal = c.transform_to(coord.Galactic)\n    cart_data = gal.data.to_cartesian()\n    unit_vector = cart_data / cart_data.norm()\n\n    v_proj = v_sun.dot(unit_vector)\n\n    return c.radial_velocity + v_proj\n\n\nrv_gsr = rv_to_gsr(icrs)\nprint(rv_gsr)", "metadata": {"file_name": "examples/coordinates/rv-to-gsr.py", "File Name": "examples/coordinates/rv-to-gsr.py", "Functions": "rv_to_gsr"}}, {"code": "# Set the WCS information manually by setting properties of the WCS\n# object.\n\nimport numpy as np\n\nfrom astropy import wcs\nfrom astropy.io import fits\n\n# Create a new WCS object.  The number of axes must be set\n# from the start\nw = wcs.WCS(naxis=2)\n\n# Set up an \"Airy's zenithal\" projection\n# Vector properties may be set with Python lists, or Numpy arrays\nw.wcs.crpix = [-234.75, 8.3393]\nw.wcs.cdelt = np.array([-0.066667, 0.066667])\nw.wcs.crval = [0, -90]\nw.wcs.ctype = [\"RA---AIR\", \"DEC--AIR\"]\nw.wcs.set_pv([(2, 1, 45.0)])\n\n# Three pixel coordinates of interest.\n# The pixel coordinates are pairs of [X, Y].\n# The \"origin\" argument indicates whether the input coordinates\n# are 0-based (as in Numpy arrays) or\n# 1-based (as in the FITS convention, for example coordinates\n# coming from DS9).\npixcrd = np.array([[0, 0], [24, 38], [45, 98]], dtype=np.float64)\n\n# Convert pixel coordinates to world coordinates.\n# The second argument is \"origin\" -- in this case we're declaring we\n# have 0-based (Numpy-like) coordinates.\nworld = w.wcs_pix2world(pixcrd, 0)\nprint(world)\n\n# Convert the same coordinates back to pixel coordinates.\npixcrd2 = w.wcs_world2pix(world, 0)\nprint(pixcrd2)\n\n# These should be the same as the original pixel coordinates, modulo\n# some floating-point error.\nassert np.max(np.abs(pixcrd - pixcrd2)) < 1e-6\n\n# The example below illustrates the use of \"origin\" to convert between\n# 0- and 1- based coordinates when executing the forward and backward\n# WCS transform.", "metadata": {"file_name": "docs/wcs/examples/programmatic.py", "File Name": "docs/wcs/examples/programmatic.py"}}, {"code": "\"\"\"\n===================================================================\nDetermining and plotting the altitude/azimuth of a celestial object\n===================================================================\n\nThis example demonstrates coordinate transformations and the creation of\nvisibility curves to assist with observing run planning.\n\nIn this example, we make a `~astropy.coordinates.SkyCoord` instance for M33.\nThe altitude-azimuth coordinates are then found using\n`astropy.coordinates.EarthLocation` and `astropy.time.Time` objects.\n\nThis example is meant to demonstrate the capabilities of the\n`astropy.coordinates` package. For more convenient and/or complex observation\nplanning, consider the `astroplan <https://astroplan.readthedocs.org/>`_\npackage.\n\n\n*By: Erik Tollerud, Kelle Cruz*\n\n*License: BSD*\n\n\n\"\"\"\n\n##############################################################################\n# Let's suppose you are planning to visit picturesque Bear Mountain State Park\n# in New York, USA. You're bringing your telescope with you (of course), and\n# someone told you M33 is a great target to observe there. You happen to know\n# you're free at 11:00 pm local time, and you want to know if it will be up.\n# Astropy can answer that.\n#\n# Import numpy and matplotlib. For the latter, use a nicer set of plot\n# parameters and set up support for plotting/converting quantities.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom astropy.visualization import astropy_mpl_style, quantity_support\n\nplt.style.use(astropy_mpl_style)\nquantity_support()\n\n\n##############################################################################\n# Import the packages necessary for finding coordinates and making\n# coordinate transformations\n\nimport astropy.units as u\nfrom astropy.coordinates import AltAz, EarthLocation, SkyCoord\nfrom astropy.time import Time\n\n##############################################################################\n# `astropy.coordinates.SkyCoord.from_name` uses Simbad to resolve object\n# names and retrieve coordinates.", "metadata": {"file_name": "examples/coordinates/plot_obs-planning.py", "File Name": "examples/coordinates/plot_obs-planning.py"}}, {"code": "However, we don't want to cyclically reference astropy in its\n# own build so we remove it here.\ndel intersphinx_mapping[\"astropy\"]\n\n# add any custom intersphinx for astropy\nintersphinx_mapping.update(\n    {\n        \"astropy-dev\": (\"https://docs.astropy.org/en/latest/\", None),\n        \"pyerfa\": (\"https://pyerfa.readthedocs.io/en/stable/\", None),\n        \"pytest\": (\"https://docs.pytest.org/en/stable/\", None),\n        \"ipython\": (\"https://ipython.readthedocs.io/en/stable/\", None),\n        \"pandas\": (\"https://pandas.pydata.org/pandas-docs/stable/\", None),\n        \"sphinx_automodapi\": (\n            \"https://sphinx-automodapi.readthedocs.io/en/stable/\",\n            None,\n        ),\n        \"asdf-astropy\": (\"https://asdf-astropy.readthedocs.io/en/latest/\", None),\n        \"fsspec\": (\"https://filesystem-spec.readthedocs.io/en/latest/\", None),\n    }\n)\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# .inc.rst mean *include* files, don't have sphinx process them\nexclude_patterns += [\"_templates\", \"changes\", \"_pkgtemplate.rst\", \"**/*.inc.rst\"]\n\n# Add any paths that contain templates here, relative to this directory.\nif \"templates_path\" not in locals():  # in case parent conf.py defines it\n    templates_path = []\ntemplates_path.append(\"_templates\")\n\nextensions += [\"sphinx_changelog\"]\n\n# Grab minversion from setup.cfg\nsetup_cfg = configparser.ConfigParser()\nsetup_cfg.read(os.path.join(os.path.pardir, \"setup.cfg\"))\n__minimum_python_version__ = setup_cfg[\"options\"][\"python_requires\"].replace(\">=\", \"\")\n\nmin_versions = {}\nfor line in metadata.requires(\"astropy\"):\n    req = Requirement(line.split(\";\")[0])\n    min_versions[req.name.lower()] = str(req.specifier)\n\n\n# This is added to the end of RST files - a good place to put substitutions to\n# be used globally.", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "\"\"\"\n========================\nTitle of Example\n========================\n\nThis example <verb> <active tense> <does something>.\n\nThe example uses <packages> to <do something> and <other package> to <do other\nthing>. Include links to referenced packages like this: `astropy.io.fits` to\nshow the astropy.io.fits or like this `~astropy.io.fits`to show just 'fits'\n\n\n*By: <names>*\n\n*License: BSD*", "metadata": {"file_name": "examples/template/example-template.py", "File Name": "examples/template/example-template.py", "Functions": "dummy"}}, {"code": "\"\"\"\n==========================================\nCreate a very large FITS file from scratch\n==========================================\n\nThis example demonstrates how to create a large file (larger than will fit in\nmemory) from scratch using `astropy.io.fits`.\n\n\n*By: Erik Bray*\n\n*License: BSD*\n\n\"\"\"\n\n##############################################################################\n#  Normally to create a single image FITS file one would do something like:\n\nimport os\n\nimport numpy as np\n\nfrom astropy.io import fits\n\ndata = np.zeros((40000, 40000), dtype=np.float64)\nhdu = fits.PrimaryHDU(data=data)\n\n##############################################################################\n# Then use the `astropy.io.fits.writeto()` method to write out the new\n# file to disk\n\nhdu.writeto('large.fits')\n\n##############################################################################\n# However, a 40000 x 40000 array of doubles is nearly twelve gigabytes! Most\n# systems won't be able to create that in memory just to write out to disk. In\n# order to create such a large file efficiently requires a little extra work,\n# and a few assumptions.\n#\n# First, it is helpful to anticipate about how large (as in, how many keywords)\n# the header will have in it. FITS headers must be written in 2880 byte\n# blocks, large enough for 36 keywords per block (including the END keyword in\n# the final block). Typical headers have somewhere between 1 and 4 blocks,\n# though sometimes more.\n#\n# Since the first thing we write to a FITS file is the header, we want to write\n# enough header blocks so that there is plenty of padding in which to add new\n# keywords without having to resize the whole file. Say you want the header to\n# use 4 blocks by default. Then, excluding the END card which Astropy will add\n# automatically, create the header and pad it out to 36 * 4 cards.", "metadata": {"file_name": "examples/io/skip_create-large-fits.py", "File Name": "examples/io/skip_create-large-fits.py"}}, {"code": "Note that, as with the positions,\n# the Galactocentric frame is a right-handed system (i.e., the Sun is at negative\n# x values) so ``v_x`` is opposite of the Galactocentric radial velocity:\n\nv_sun = [11.1, 244, 7.25] * (u.km / u.s)  # [vx, vy, vz]\ngc_frame = coord.Galactocentric(\n    galcen_distance=8*u.kpc,\n    galcen_v_sun=v_sun,\n    z_sun=0*u.pc)\n\n##############################################################################\n# We can then transform to this frame instead, with our custom parameters:\n\ngc2 = c1.transform_to(gc_frame)\nprint(gc2.v_x, gc2.v_y, gc2.v_z)\n\n##############################################################################\n# It's sometimes useful to specify the solar motion using the `proper motion\n# of Sgr A* <https://arxiv.org/abs/astro-ph/0408107>`_ instead of Cartesian\n# velocity components. With an assumed distance, we can convert proper motion\n# components to Cartesian velocity components using `astropy.units`:\n\ngalcen_distance = 8*u.kpc\npm_gal_sgrA = [-6.379, -0.202] * u.mas/u.yr # from Reid & Brunthaler 2004\nvy, vz = -(galcen_distance * pm_gal_sgrA).to(u.km/u.s, u.dimensionless_angles())\n\n##############################################################################\n# We still have to assume a line-of-sight velocity for the Galactic center,\n# which we will again take to be 11 km/s:\nvx = 11.1 * u.km/u.s\nv_sun2 = u.Quantity([vx, vy, vz])  # List of Quantity -> a single Quantity\n\ngc_frame2 = coord.Galactocentric(galcen_distance=galcen_distance,\n                                 galcen_v_sun=v_sun2,\n                                 z_sun=0*u.pc)\ngc3 = c1.transform_to(gc_frame2)\nprint(gc3.v_x, gc3.v_y, gc3.v_z)\n\n##############################################################################\n# The transformations also work in the opposite direction. This can be useful\n# for transforming simulated or theoretical data to observable quantities.", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "\"\"\"\n=====================================================\nCreate a multi-extension FITS (MEF) file from scratch\n=====================================================\n\nThis example demonstrates how to create a multi-extension FITS (MEF)\nfile from scratch using `astropy.io.fits`.\n\n\n*By: Erik Bray*\n\n*License: BSD*\n\n\n\"\"\"\n\nimport os\n\nfrom astropy.io import fits\n\n##############################################################################\n# HDUList objects are used to hold all the HDUs in a FITS file. This\n# ``HDUList`` class is a subclass of Python's builtin `list` and can be\n# created from scratch. For example, to create a FITS file with\n# three extensions:\n\nnew_hdul = fits.HDUList()\nnew_hdul.append(fits.ImageHDU())\nnew_hdul.append(fits.ImageHDU())\n\n##############################################################################\n# Write out the new file to disk:\n\nnew_hdul.writeto('test.fits')\n\n##############################################################################\n# Alternatively, the HDU instances can be created first (or read from an\n# existing FITS file).\n#\n# Create a multi-extension FITS file with two empty IMAGE extensions (a\n# default PRIMARY HDU is prepended automatically if one is not specified;\n# we use ``overwrite=True`` to overwrite the file if it already exists):\n\nhdu1 = fits.PrimaryHDU()\nhdu2 = fits.ImageHDU()\nnew_hdul = fits.HDUList([hdu1, hdu2])\nnew_hdul.writeto('test.fits', overwrite=True)\n\n##############################################################################\n# Finally, we'll remove the file we created:\n\nos.remove('test.fits')", "metadata": {"file_name": "examples/io/create-mef.py", "File Name": "examples/io/create-mef.py"}}, {"code": "def load_wcs_from_file(filename):\n    # Load the FITS hdulist using astropy.io.fits\n    hdulist = fits.open(filename)\n\n    # Parse the WCS keywords in the primary HDU\n    w = wcs.WCS(hdulist[0].header)\n\n    # Print out the \"name\" of the WCS, as defined in the FITS header\n    print(w.wcs.name)\n\n    # Print out all of the settings that were parsed from the header\n    w.wcs.print_contents()\n\n    # Three pixel coordinates of interest.\n    # Note we've silently assumed an NAXIS=2 image here.\n    # The pixel coordinates are pairs of [X, Y].\n    # The \"origin\" argument indicates whether the input coordinates\n    # are 0-based (as in Numpy arrays) or\n    # 1-based (as in the FITS convention, for example coordinates\n    # coming from DS9).\n    pixcrd = np.array([[0, 0], [24, 38], [45, 98]], dtype=np.float64)\n\n    # Convert pixel coordinates to world coordinates\n    # The second argument is \"origin\" -- in this case we're declaring we\n    # have 0-based (Numpy-like) coordinates.\n    world = w.wcs_pix2world(pixcrd, 0)\n    print(world)\n\n    # Convert the same coordinates back to pixel coordinates.\n    pixcrd2 = w.wcs_world2pix(world, 0)\n    print(pixcrd2)\n\n    # These should be the same as the original pixel coordinates, modulo\n    # some floating-point error.\n    assert np.max(np.abs(pixcrd - pixcrd2)) < 1e-6\n\n    # The example below illustrates the use of \"origin\" to convert between\n    # 0- and 1- based coordinates when executing the forward and backward\n    # WCS transform.\n    x = 0\n    y = 0\n    origin = 0\n    assert (w.wcs_pix2world(x, y, origin) ==\n            w.wcs_pix2world(x + 1, y + 1, origin + 1))\n\n\nif __name__ == '__main__':\n    load_wcs_from_file(sys.argv[-1])", "metadata": {"file_name": "docs/wcs/examples/from_file.py", "File Name": "docs/wcs/examples/from_file.py", "Functions": "load_wcs_from_file"}}, {"code": "\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom PIL import Image\n\nfrom astropy.io import fits\nfrom astropy.visualization import astropy_mpl_style\n\n##############################################################################\n# Set up matplotlib and use a nicer set of plot parameters\n\nplt.style.use(astropy_mpl_style)\n\n##############################################################################\n# Load and display the original 3-color jpeg image:\n\nimage = Image.open('Hs-2009-14-a-web.jpg')\nxsize, ysize = image.size\nprint(f\"Image size: {ysize} x {xsize}\")\nprint(f\"Image bands: {image.getbands()}\")\nax = plt.imshow(image)\n\n##############################################################################\n# Split the three channels (RGB) and get the data as Numpy arrays. The arrays\n# are flattened, so they are 1-dimensional:\n\nr, g, b = image.split()\nr_data = np.array(r.getdata()) # data is now an array of length ysize*xsize\ng_data = np.array(g.getdata())\nb_data = np.array(b.getdata())\nprint(r_data.shape)\n\n##############################################################################\n# Reshape the image arrays to be 2-dimensional:\n\nr_data = r_data.reshape(ysize, xsize) # data is now a matrix (ysize, xsize)\ng_data = g_data.reshape(ysize, xsize)\nb_data = b_data.reshape(ysize, xsize)\nprint(r_data.shape)\n\n##############################################################################\n# Write out the channels as separate FITS images.\n# Add and visualize header info\n\nred = fits.PrimaryHDU(data=r_data)\nred.header['LATOBS'] = \"32:11:56\" # add spurious header info\nred.header['LONGOBS'] = \"110:56\"\nred.writeto('red.fits')\n\ngreen = fits.PrimaryHDU(data=g_data)\ngreen.header['LATOBS'] = \"32:11:56\"\ngreen.header['LONGOBS'] = \"110:56\"\ngreen.writeto('green.fits')\n\nblue = fits.PrimaryHDU(data=b_data)\nblue.header['LATOBS'] = \"32:11:56\"\nblue.header['LONGOBS'] = \"110:56\"\nblue.writeto('blue.fits')\n\nfrom pprint import pprint\n\npprint(red.header)\n\n##############################################################################\n# Delete the files created\n\nimport os\n\nos.remove('red.fits')\nos.remove('green.fits')\nos.remove('blue.fits')", "metadata": {"file_name": "examples/io/split-jpeg-to-fits.py", "File Name": "examples/io/split-jpeg-to-fits.py"}}, {"code": "# Code comments not preceded by the hash splitter are left in code blocks.\n\nstring = \"\"\"\nTriple-quoted string which tries to break parser but doesn't.\n\"\"\"\n\n############################################################################\n# Output of the script is captured:\n\nprint('Some output from Python')\n\n############################################################################\n# Finally, I'll call ``show`` at the end just so someone running the Python\n# code directly will see the plots; this is not necessary for creating the docs\n\nplt.show()", "metadata": {"file_name": "examples/template/example-template.py", "File Name": "examples/template/example-template.py", "Functions": "dummy"}}, {"code": "##############################################################################\n# Breaking this down line-by-line, we define the class as a subclass of\n# `~astropy.coordinates.BaseCoordinateFrame`. Then we include a descriptive\n# docstring.  The final lines are class-level attributes that specify the\n# default representation for the data, default differential for the velocity\n# information, and mappings from the attribute names used by representation\n# objects to the names that are to be used by the ``Sagittarius`` frame. In this\n# case we override the names in the spherical representations but don't do\n# anything with other representations like cartesian or cylindrical.\n#\n# Next we have to define the transformation from this coordinate system to some\n# other built-in coordinate system; we will use Galactic coordinates. We can do\n# this by defining functions that return transformation matrices, or by simply\n# defining a function that accepts a coordinate and returns a new coordinate in\n# the new system. Because the transformation to the Sagittarius coordinate\n# system is just a spherical rotation from Galactic coordinates, we'll just\n# define a function that returns this matrix. We'll start by constructing the\n# transformation matrix using pre-determined Euler angles and the\n# ``rotation_matrix`` helper function:\n\nSGR_PHI = (180 + 3.75) * u.degree # Euler angles (from Law & Majewski 2010)\nSGR_THETA = (90 - 13.46) * u.degree\nSGR_PSI = (180 + 14.111534) * u.degree\n\n# Generate the rotation matrix using the x-convention (see Goldstein)\nSGR_MATRIX = (\n    np.diag([1.,1.,-1.])\n    @ rotation_matrix(SGR_PSI, \"z\")\n    @ rotation_matrix(SGR_THETA, \"x\")\n    @ rotation_matrix(SGR_PHI, \"z\")\n)\n\n\n##############################################################################\n# Since we already constructed the transformation (rotation) matrix above, and\n# the inverse of a rotation matrix is just its transpose, the required\n# transformation functions are very simple:\n\n@frame_transform_graph.transform(coord.StaticMatrixTransform, coord.Galactic, Sagittarius)\ndef galactic_to_sgr():\n    \"\"\"Compute the Galactic spherical to heliocentric Sgr transformation matrix.\"\"\"\n    return SGR_MATRIX", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "init_filename = os.path.join(final_dir, \"__init__.py\")\n            if not os.path.exists(os.path.join(final_dir, \"__init__.py\")):\n                os.makedirs(final_dir, exist_ok=True)\n                with open(os.path.join(final_dir, \"__init__.py\"), \"w\") as f:\n                    f.write(\"#\")\n    # Copy over all conftest.py files\n    for file in files:\n        if file == \"conftest.py\":\n            final_file = os.path.relpath(os.path.join(test_root, file), ROOT)\n            shutil.copy2(os.path.join(root, file), final_file)\n\n# Add the top-level __init__.py file\nwith open(os.path.join(\"astropy_tests\", \"__init__.py\"), \"w\") as f:\n    f.write(\"#\")\n\n# Remove test file that tries to import all sub-packages at collection time\nos.remove(\n    os.path.join(\"astropy_tests\", \"utils\", \"iers\", \"tests\", \"test_leap_second.py\")\n)\n\n# Remove convolution tests for now as there are issues with the loading of the C extension.\n# FIXME: one way to fix this would be to migrate the convolution C extension away from using\n# ctypes and using the regular extension mechanism instead.\nshutil.rmtree(os.path.join(\"astropy_tests\", \"convolution\"))\nos.remove(os.path.join(\"astropy_tests\", \"modeling\", \"tests\", \"test_convolution.py\"))\nos.remove(os.path.join(\"astropy_tests\", \"modeling\", \"tests\", \"test_core.py\"))\nos.remove(os.path.join(\"astropy_tests\", \"visualization\", \"tests\", \"test_lupton_rgb.py\"))\n\n# FIXME: PIL minversion check does not work\nos.remove(\n    os.path.join(\"astropy_tests\", \"visualization\", \"wcsaxes\", \"tests\", \"test_misc.py\")\n)\nos.remove(\n    os.path.join(\"astropy_tests\", \"visualization\", \"wcsaxes\", \"tests\", \"test_wcsapi.py\")\n)\n\n# FIXME: The following tests rely on the fully qualified name of classes which\n# don't seem to be the same.", "metadata": {"file_name": ".pyinstaller/run_astropy_tests.py", "File Name": ".pyinstaller/run_astropy_tests.py"}}, {"code": "\"\"\"\n\n################################################################################\n# Import the required Astropy packages:\n\nimport astropy.coordinates as coord\nimport astropy.units as u\n\n################################################################################\n# Use the latest convention for the Galactocentric coordinates\ncoord.galactocentric_frame_defaults.set('latest')\n\n################################################################################\n# For this example, let's work with the coordinates and barycentric radial\n# velocity of the star HD 155967, as obtained from\n# `Simbad <https://simbad.unistra.fr/simbad/>`_:\nicrs = coord.SkyCoord(ra=258.58356362*u.deg, dec=14.55255619*u.deg,\n                      radial_velocity=-16.1*u.km/u.s, frame='icrs')\n\n################################################################################\n# We next need to decide on the velocity of the Sun in the assumed GSR frame.\n# We'll use the same velocity vector as used in the\n# `~astropy.coordinates.Galactocentric` frame, and convert it to a\n# `~astropy.coordinates.CartesianRepresentation` object using the\n# ``.to_cartesian()`` method of the\n# `~astropy.coordinates.CartesianDifferential` object ``galcen_v_sun``:\nv_sun = coord.Galactocentric().galcen_v_sun.to_cartesian()\n\n################################################################################\n# We now need to get a unit vector in the assumed Galactic frame from the sky\n# position in the ICRS frame above. We'll use this unit vector to project the\n# solar velocity onto the line-of-sight:\ngal = icrs.transform_to(coord.Galactic)\ncart_data = gal.data.to_cartesian()\nunit_vector = cart_data / cart_data.norm()\n\n################################################################################\n# Now we project the solar velocity using this unit vector:\nv_proj = v_sun.dot(unit_vector)\n\n################################################################################\n# Finally, we add the projection of the solar velocity to the radial velocity\n# to get a GSR radial velocity:\nrv_gsr = icrs.radial_velocity + v_proj\nprint(rv_gsr)", "metadata": {"file_name": "examples/coordinates/rv-to-gsr.py", "File Name": "examples/coordinates/rv-to-gsr.py", "Functions": "rv_to_gsr"}}, {"code": "\"\"\"\n==================\nEdit a FITS header\n==================\n\nThis example describes how to edit a value in a FITS header\nusing `astropy.io.fits`.\n\n\n*By: Adrian Price-Whelan*\n\n*License: BSD*\n\n\n\"\"\"\n\nfrom astropy.io import fits\nfrom astropy.utils.data import get_pkg_data_filename\n\n##############################################################################\n# Download a FITS file:\n\nfits_file = get_pkg_data_filename('tutorials/FITS-Header/input_file.fits')\n\n##############################################################################\n# Look at contents of the FITS file\n\nfits.info(fits_file)\n\n##############################################################################\n# Look at the headers of the two extensions:\n\nprint(\"Before modifications:\")\nprint()\nprint(\"Extension 0:\")\nprint(repr(fits.getheader(fits_file, 0)))\nprint()\nprint(\"Extension 1:\")\nprint(repr(fits.getheader(fits_file, 1)))\n\n##############################################################################\n# `astropy.io.fits` provides an object-oriented interface for reading and\n# interacting with FITS files, but for small operations (like this example) it\n# is often easier to use the\n# `convenience functions <https://docs.astropy.org/en/latest/io/fits/index.html#convenience-functions>`_.\n#\n# To edit a single header value in the header for extension 0, use the\n# `~astropy.io.fits.setval()` function. For example, set the OBJECT keyword\n# to 'M31':\n\nfits.setval(fits_file, 'OBJECT', value='M31')\n\n##############################################################################\n# With no extra arguments, this will modify the header for extension 0, but\n# this can be changed using the ``ext`` keyword argument. For example, we can\n# specify extension 1 instead:\n\nfits.setval(fits_file, 'OBJECT', value='M31', ext=1)\n\n##############################################################################\n# This can also be used to create a new keyword-value pair (\"card\" in FITS\n# lingo):\n\nfits.setval(fits_file, 'ANEWKEY', value='some value')\n\n##############################################################################\n# Again, this is useful for one-off modifications, but can be inefficient\n# for operations like editing multiple headers in the same file\n# because `~astropy.io.fits.setval()` loads the whole file each time it\n# is called.", "metadata": {"file_name": "examples/io/modify-fits-header.py", "File Name": "examples/io/modify-fits-header.py"}}, {"code": "class Sagittarius(coord.BaseCoordinateFrame):\n    \"\"\"\n    A Heliocentric spherical coordinate system defined by the orbit\n    of the Sagittarius dwarf galaxy, as described in\n        https://ui.adsabs.harvard.edu/abs/2003ApJ...599.1082M\n    and further explained in\n        https://www.stsci.edu/~dlaw/Sgr/.\n\n    Parameters\n    ----------\n    representation : `~astropy.coordinates.BaseRepresentation` or None\n        A representation object or None to have no data (or use the other keywords)\n    Lambda : `~astropy.coordinates.Angle`, optional, must be keyword\n        The longitude-like angle corresponding to Sagittarius' orbit.\n    Beta : `~astropy.coordinates.Angle`, optional, must be keyword\n        The latitude-like angle corresponding to Sagittarius' orbit.\n    distance : `~astropy.units.Quantity`, optional, must be keyword\n        The Distance for this object along the line-of-sight.\n    pm_Lambda_cosBeta : `~astropy.units.Quantity`, optional, must be keyword\n        The proper motion along the stream in ``Lambda`` (including the\n        ``cos(Beta)`` factor) for this object (``pm_Beta`` must also be given).\n    pm_Beta : `~astropy.units.Quantity`, optional, must be keyword\n        The proper motion in Declination for this object (``pm_ra_cosdec`` must\n        also be given).\n    radial_velocity : `~astropy.units.Quantity`, optional, keyword-only\n        The radial velocity of this object.\n\n    \"\"\"\n\n    default_representation = coord.SphericalRepresentation\n    default_differential = coord.SphericalCosLatDifferential\n\n    frame_specific_representation_info = {\n        coord.SphericalRepresentation: [\n            coord.RepresentationMapping('lon', 'Lambda'),\n            coord.RepresentationMapping('lat', 'Beta'),\n            coord.RepresentationMapping('distance', 'distance')]\n    }", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "# Define the astropy.wcs.WCS object using a Python dictionary as input\n\nimport astropy.wcs\n\nwcs_dict = {\n'CTYPE1': 'WAVE    ', 'CUNIT1': 'Angstrom', 'CDELT1': 0.2, 'CRPIX1': 0, 'CRVAL1': 10, 'NAXIS1': 5,\n'CTYPE2': 'HPLT-TAN', 'CUNIT2': 'deg', 'CDELT2': 0.5, 'CRPIX2': 2, 'CRVAL2': 0.5, 'NAXIS2': 4,\n'CTYPE3': 'HPLN-TAN', 'CUNIT3': 'deg', 'CDELT3': 0.4, 'CRPIX3': 2, 'CRVAL3': 1, 'NAXIS3': 3}\ninput_wcs = astropy.wcs.WCS(wcs_dict)", "metadata": {"file_name": "docs/wcs/examples/cube_wcs.py", "File Name": "docs/wcs/examples/cube_wcs.py"}}, {"code": "\"\"\"\n=====================================================================\nAccessing data stored as a table in a multi-extension FITS (MEF) file\n=====================================================================\n\nFITS files can often contain large amount of multi-dimensional data and\ntables. This example opens a FITS file with information\nfrom Chandra's HETG-S instrument.\n\nThe example uses `astropy.utils.data` to download multi-extension FITS (MEF)\nfile, `astropy.io.fits` to investigate the header, and\n`astropy.table.Table` to explore the data.\n\n\n*By: Lia Corrales, Adrian Price-Whelan, and Kelle Cruz*\n\n*License: BSD*\n\n\n\"\"\"\n\n##############################################################################\n# Use `astropy.utils.data` subpackage to download the FITS file used in this\n# example. Also import `~astropy.table.Table` from the `astropy.table` subpackage\n# and `astropy.io.fits`\n\nfrom astropy.io import fits\nfrom astropy.table import Table\nfrom astropy.utils.data import get_pkg_data_filename\n\n##############################################################################\n# Download a FITS file\n\nevent_filename = get_pkg_data_filename('tutorials/FITS-tables/chandra_events.fits')\n\n##############################################################################\n# Display information about the contents of the FITS file.\n\nfits.info(event_filename)\n\n##############################################################################\n# Extension 1, EVENTS, is a Table that contains information about each X-ray\n# photon that hit Chandra's HETG-S detector.\n#\n# Use `~astropy.table.Table` to read the table\n\nevents = Table.read(event_filename, hdu=1)\n\n##############################################################################\n# Print the column names of the Events Table.\n\nprint(events.columns)\n\n##############################################################################\n# If a column contains unit information, it will have an associated\n# `astropy.units` object.\n\nprint(events['energy'].unit)\n\n##############################################################################\n# Print the data stored in the Energy column.\n\nprint(events['energy'])", "metadata": {"file_name": "examples/io/fits-tables.py", "File Name": "examples/io/fits-tables.py"}}, {"code": "\"\"\"\n========================================================================\nTransforming positions and velocities to and from a Galactocentric frame\n========================================================================\n\nThis document shows a few examples of how to use and customize the\n`~astropy.coordinates.Galactocentric` frame to transform Heliocentric sky\npositions, distance, proper motions, and radial velocities to a Galactocentric,\nCartesian frame, and the same in reverse.\n\nThe main configurable parameters of the `~astropy.coordinates.Galactocentric`\nframe control the position and velocity of the solar system barycenter within\nthe Galaxy. These are specified by setting the ICRS coordinates of the\nGalactic center, the distance to the Galactic center (the sun-galactic center\nline is always assumed to be the x-axis of the Galactocentric frame), and the\nCartesian 3-velocity of the sun in the Galactocentric frame. We'll first\ndemonstrate how to customize these values, then show how to set the solar motion\ninstead by inputting the proper motion of Sgr A*.\n\nNote that, for brevity, we may refer to the solar system barycenter as just \"the\nsun\" in the examples below.\n\n\n*By: Adrian Price-Whelan*\n\n*License: BSD*\n\n\n\"\"\"\n\n##############################################################################\n# Make `print` work the same in all versions of Python, set up numpy,\n# matplotlib, and use a nicer set of plot parameters:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom astropy.visualization import astropy_mpl_style\n\nplt.style.use(astropy_mpl_style)\n\n\n##############################################################################\n# Import the necessary astropy subpackages\n\nimport astropy.coordinates as coord\nimport astropy.units as u\n\n##############################################################################\n# Let's first define a barycentric coordinate and velocity in the ICRS frame.", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(\"index\", project.lower(), project + \" Documentation\", [author], 1)]\n\n# Setting this URL is requited by sphinx-astropy\ngithub_issues_url = \"https://github.com/astropy/astropy/issues/\"\nedit_on_github_branch = \"main\"\n\n# Enable nitpicky mode - which ensures that all references in the docs\n# resolve.\n\nnitpicky = True\n# See docs/nitpick-exceptions file for the actual listing.\nnitpick_ignore = []\nfor line in open(\"nitpick-exceptions\"):\n    if line.strip() == \"\" or line.startswith(\"#\"):\n        continue\n    dtype, target = line.split(None, 1)\n    nitpick_ignore.append((dtype, target.strip()))\n\n# -- Options for the Sphinx gallery -------------------------------------------\n\ntry:\n    import warnings\n\n    import sphinx_gallery\n\n    extensions += [\"sphinx_gallery.gen_gallery\"]\n\n    sphinx_gallery_conf = {\n        \"backreferences_dir\": \"generated/modules\",  # path to store the module using example template\n        \"filename_pattern\": \"^((?!skip_).)*$\",  # execute all examples except those that start with \"skip_\"\n        \"examples_dirs\": f\"..{os.sep}examples\",  # path to the examples scripts\n        \"gallery_dirs\": \"generated/examples\",  # path to save gallery generated examples\n        \"reference_url\": {\n            \"astropy\": None,\n            \"matplotlib\": \"https://matplotlib.org/stable/\",\n            \"numpy\": \"https://numpy.org/doc/stable/\",\n        },\n        \"abort_on_example_error\": True,\n    }\n\n    # Filter out backend-related warnings as described in\n    # https://github.com/sphinx-gallery/sphinx-gallery/pull/564\n    warnings.filterwarnings(\n        \"ignore\",\n        category=UserWarning,\n        message=(\n            \"Matplotlib is currently using agg, which is a\"\n            \" non-GUI backend, so cannot show the figure.\"\n        ),\n    )\n\nexcept ImportError:\n    sphinx_gallery = None", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "##############################################################################\n# Do the same with `~astropy.coordinates.get_body` to find when the moon is\n# up. Be aware that this will need to download a 10MB file from the internet\n# to get a precise location of the moon.\n\nfrom astropy.coordinates import get_body\n\nmoon_July12_to_13 = get_body(\"moon\", times_July12_to_13)\nmoonaltazs_July12_to_13 = moon_July12_to_13.transform_to(frame_July12_to_13)\n\n##############################################################################\n# Find the alt,az coordinates of M33 at those same times:\n\nm33altazs_July12_to_13 = m33.transform_to(frame_July12_to_13)\n\n##############################################################################\n# Make a beautiful figure illustrating nighttime and the altitudes of M33 and\n# the Sun over that time:\n\nplt.plot(delta_midnight, sunaltazs_July12_to_13.alt, color='r', label='Sun')\nplt.plot(delta_midnight, moonaltazs_July12_to_13.alt, color=[0.75]*3, ls='--', label='Moon')\nplt.scatter(delta_midnight, m33altazs_July12_to_13.alt,\n            c=m33altazs_July12_to_13.az, label='M33', lw=0, s=8,\n            cmap='viridis')\nplt.fill_between(delta_midnight, 0*u.deg, 90*u.deg,\n                 sunaltazs_July12_to_13.alt < -0*u.deg, color='0.5', zorder=0)\nplt.fill_between(delta_midnight, 0*u.deg, 90*u.deg,\n                 sunaltazs_July12_to_13.alt < -18*u.deg, color='k', zorder=0)\nplt.colorbar().set_label('Azimuth [deg]')\nplt.legend(loc='upper left')\nplt.xlim(-12*u.hour, 12*u.hour)\nplt.xticks((np.arange(13)*2-12)*u.hour)\nplt.ylim(0*u.deg, 90*u.deg)\nplt.xlabel('Hours from EDT Midnight')\nplt.ylabel('Altitude [deg]')\nplt.show()", "metadata": {"file_name": "examples/coordinates/plot_obs-planning.py", "File Name": "examples/coordinates/plot_obs-planning.py"}}, {"code": "x = 0\ny = 0\norigin = 0\nassert (w.wcs_pix2world(x, y, origin) ==\n        w.wcs_pix2world(x + 1, y + 1, origin + 1))\n\n# Now, write out the WCS object as a FITS header\nheader = w.to_header()\n\n# header is an astropy.io.fits.Header object.  We can use it to create a new\n# PrimaryHDU and write it to a file.\nhdu = fits.PrimaryHDU(header=header)\n# Save to FITS file\n# hdu.writeto('test.fits')", "metadata": {"file_name": "docs/wcs/examples/programmatic.py", "File Name": "docs/wcs/examples/programmatic.py"}}, {"code": "def setup(app):\n    if sphinx_gallery is None:\n        msg = (\n            \"The sphinx_gallery extension is not installed, so the \"\n            \"gallery will not be built.  You will probably see \"\n            \"additional warnings about undefined references due \"\n            \"to this.\"\n        )\n        try:\n            app.warn(msg)\n        except AttributeError:\n            # Sphinx 1.6+\n            from sphinx.util import logging\n\n            logger = logging.getLogger(__name__)\n            logger.warning(msg)\n\n    # Generate the page from Jinja template\n    app.connect(\"source-read\", rstjinja)\n    # Set this to higher priority than intersphinx; this way when building\n    # dev docs astropy-dev: targets will go to the local docs instead of the\n    # intersphinx mapping\n    app.connect(\"missing-reference\", resolve_astropy_and_dev_reference, priority=400)", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "Here are\n# the positions and velocities of the rings; note that in the velocity plot,\n# the velocities of the 4 rings are identical and thus overlaid under the same\n# curve:\nfig,axes = plt.subplots(1, 2, figsize=(12,6))\n\n# Positions\naxes[0].plot(gc_rings.x.T, gc_rings.y.T, marker='None', linewidth=3)\naxes[0].text(-8., 0, r'$\\odot$', fontsize=20)\n\naxes[0].set_xlim(-30, 30)\naxes[0].set_ylim(-30, 30)\n\naxes[0].set_xlabel('$x$ [kpc]')\naxes[0].set_ylabel('$y$ [kpc]')\n\n# Velocities\naxes[1].plot(gc_rings.v_x.T, gc_rings.v_y.T, marker='None', linewidth=3)\n\naxes[1].set_xlim(-250, 250)\naxes[1].set_ylim(-250, 250)\n\naxes[1].set_xlabel(f\"$v_x$ [{(u.km / u.s).to_string('latex_inline')}]\")\naxes[1].set_ylabel(f\"$v_y$ [{(u.km / u.s).to_string('latex_inline')}]\")\n\nfig.tight_layout()\n\nplt.show()\n\n##############################################################################\n# Now we can transform to Galactic coordinates and visualize the rings in\n# observable coordinates:\ngal_rings = gc_rings.transform_to(coord.Galactic)\n\nfig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfor i in range(len(ring_distances)):\n    ax.plot(gal_rings[i].l.degree, gal_rings[i].pm_l_cosb.value,\n            label=str(ring_distances[i]), marker='None', linewidth=3)\n\nax.set_xlim(360, 0)\n\nax.set_xlabel('$l$ [deg]')\nax.set_ylabel(fr'$\\mu_l \\, \\cos b$ [{(u.mas/u.yr).to_string(\"latex_inline\")}]')\n\nax.legend()\n\nplt.show()", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "#\n# Get the coordinates of M33:\n\nm33 = SkyCoord.from_name('M33')\n\n##############################################################################\n# Use `astropy.coordinates.EarthLocation` to provide the location of Bear\n# Mountain and set the time to 11pm EDT on 2012 July 12:\n\nbear_mountain = EarthLocation(lat=41.3*u.deg, lon=-74*u.deg, height=390*u.m)\nutcoffset = -4*u.hour  # Eastern Daylight Time\ntime = Time('2012-7-12 23:00:00') - utcoffset\n\n##############################################################################\n# `astropy.coordinates.EarthLocation.get_site_names` and\n# `~astropy.coordinates.EarthLocation.get_site_names` can be used to get\n# locations of major observatories.\n#\n# Use `astropy.coordinates` to find the Alt, Az coordinates of M33 at as\n# observed from Bear Mountain at 11pm on 2012 July 12.\n\nm33altaz = m33.transform_to(AltAz(obstime=time,location=bear_mountain))\nprint(f\"M33's Altitude = {m33altaz.alt:.2}\")\n\n##############################################################################\n# This is helpful since it turns out M33 is barely above the horizon at this\n# time. It's more informative to find M33's airmass over the course of\n# the night.", "metadata": {"file_name": "examples/coordinates/plot_obs-planning.py", "File Name": "examples/coordinates/plot_obs-planning.py"}}, {"code": "# We'll use the data for the star HD 39881 from the `Simbad\n# <https://simbad.unistra.fr/simbad/>`_ database:\n\nc1 = coord.SkyCoord(ra=89.014303*u.degree, dec=13.924912*u.degree,\n                    distance=(37.59*u.mas).to(u.pc, u.parallax()),\n                    pm_ra_cosdec=372.72*u.mas/u.yr,\n                    pm_dec=-483.69*u.mas/u.yr,\n                    radial_velocity=0.37*u.km/u.s,\n                    frame='icrs')\n\n##############################################################################\n# This is a high proper-motion star; suppose we'd like to transform its position\n# and velocity to a Galactocentric frame to see if it has a large 3D velocity\n# as well. To use the Astropy default solar position and motion parameters, we\n# can simply do:\n\ngc1 = c1.transform_to(coord.Galactocentric)\n\n##############################################################################\n# From here, we can access the components of the resulting\n# `~astropy.coordinates.Galactocentric` instance to see the 3D Cartesian\n# velocity components:\n\nprint(gc1.v_x, gc1.v_y, gc1.v_z)\n\n##############################################################################\n# The default parameters for the `~astropy.coordinates.Galactocentric` frame\n# are detailed in the linked documentation, but we can modify the most commonly\n# changes values using the keywords ``galcen_distance``, ``galcen_v_sun``, and\n# ``z_sun`` which set the sun-Galactic center distance, the 3D velocity vector\n# of the sun, and the height of the sun above the Galactic midplane,\n# respectively. The velocity of the sun can be specified as an\n# `~astropy.units.Quantity` object with velocity units and is interpreted as a\n# Cartesian velocity, as in the example below.", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "\"\"\"\n=======================================\nRead and plot an image from a FITS file\n=======================================\n\nThis example opens an image stored in a FITS file and displays it to the screen.\n\nThis example uses `astropy.utils.data` to download the file, `astropy.io.fits` to open\nthe file, and `matplotlib.pyplot` to display the image.\n\n\n*By: Lia R. Corrales, Adrian Price-Whelan, Kelle Cruz*\n\n*License: BSD*\n\n\n\"\"\"\n\n##############################################################################\n# Set up matplotlib and use a nicer set of plot parameters\n\nimport matplotlib.pyplot as plt\n\nfrom astropy.visualization import astropy_mpl_style\n\nplt.style.use(astropy_mpl_style)\n\n##############################################################################\n# Download the example FITS files used by this example:\n\nfrom astropy.io import fits\nfrom astropy.utils.data import get_pkg_data_filename\n\nimage_file = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\n\n##############################################################################\n# Use `astropy.io.fits.info()` to display the structure of the file:\n\nfits.info(image_file)\n\n##############################################################################\n# Generally the image information is located in the Primary HDU, also known\n# as extension 0. Here, we use `astropy.io.fits.getdata()` to read the image\n# data from this first extension using the keyword argument ``ext=0``:\n\nimage_data = fits.getdata(image_file, ext=0)\n\n##############################################################################\n# The data is now stored as a 2D numpy array. Print the dimensions using the\n# shape attribute:\n\nprint(image_data.shape)\n\n##############################################################################\n# Display the image data:\n\nplt.figure()\nplt.imshow(image_data, cmap='gray')\nplt.colorbar()", "metadata": {"file_name": "examples/io/plot_fits-image.py", "File Name": "examples/io/plot_fits-image.py"}}, {"code": "r\"\"\"\n==========================================================\nCreate a new coordinate class (for the Sagittarius stream)\n==========================================================\n\nThis document describes in detail how to subclass and define a custom spherical\ncoordinate frame, as discussed in :ref:`astropy:astropy-coordinates-design` and\nthe docstring for `~astropy.coordinates.BaseCoordinateFrame`. In this example,\nwe will define a coordinate system defined by the plane of orbit of the\nSagittarius Dwarf Galaxy (hereafter Sgr; as defined in Majewski et al. 2003).\nThe Sgr coordinate system is often referred to in terms of two angular\ncoordinates, :math:`\\Lambda,B`.\n\nTo do this, we need to define a subclass of\n`~astropy.coordinates.BaseCoordinateFrame` that knows the names and units of the\ncoordinate system angles in each of the supported representations.  In this case\nwe support `~astropy.coordinates.SphericalRepresentation` with \"Lambda\" and\n\"Beta\". Then we have to define the transformation from this coordinate system to\nsome other built-in system. Here we will use Galactic coordinates, represented\nby the `~astropy.coordinates.Galactic` class.\n\nSee Also\n--------\n* The `gala package <http://gala.adrian.pw/>`_, which defines a number of\n  Astropy coordinate frames for stellar stream coordinate systems.\n* Majewski et al. 2003, \"A Two Micron All Sky Survey View of the Sagittarius\n  Dwarf Galaxy. I. Morphology of the Sagittarius Core and Tidal Arms\",\n  https://arxiv.org/abs/astro-ph/0304198\n* Law & Majewski 2010, \"The Sagittarius Dwarf Galaxy: A Model for Evolution in a\n  Triaxial Milky Way Halo\", https://arxiv.org/abs/1003.1132\n* David Law's Sgr info page https://www.stsci.edu/~dlaw/Sgr/\n\n\n*By: Adrian Price-Whelan, Erik Tollerud*\n\n*License: BSD*", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "# Load the WCS information from a fits header, and use it\n# to convert pixel coordinates to world coordinates.\n\nimport sys\n\nimport numpy as np\n\nfrom astropy import wcs\nfrom astropy.io import fits", "metadata": {"file_name": "docs/wcs/examples/from_file.py", "File Name": "docs/wcs/examples/from_file.py", "Functions": "load_wcs_from_file"}}, {"code": "def resolve_astropy_and_dev_reference(app, env, node, contnode):\n    \"\"\"\n    Reference targets for ``astropy:`` and ``astropy-dev:`` are special cases.\n\n    Documentation links in astropy can be set up as intersphinx links so that\n    affiliate packages do not have to override the docstrings when building\n    the docs.\n\n    If we are building the development docs it is a local ref targeting the\n    label ``astropy-dev:<label>``, but for stable docs it should be an\n    intersphinx resolution to the development docs.\n\n    See https://github.com/astropy/astropy/issues/11366\n    \"\"\"\n    # should the node be processed?\n    reftarget = node.get(\"reftarget\")  # str or None\n    if str(reftarget).startswith(\"astropy:\"):\n        # This allows Astropy to use intersphinx links to itself and have\n        # them resolve to local links. Downstream packages will see intersphinx.\n        # TODO! deprecate this if sphinx-doc/sphinx/issues/9169 is implemented.\n        process, replace = True, \"astropy:\"\n    elif dev and str(reftarget).startswith(\"astropy-dev:\"):\n        process, replace = True, \"astropy-dev:\"\n    else:\n        process, replace = False, \"\"\n\n    # make link local\n    if process:\n        reftype = node.get(\"reftype\")\n        refdoc = node.get(\"refdoc\", app.env.docname)\n        # convert astropy intersphinx targets to local links.\n        # there are a few types of intersphinx link patterns, as described in\n        # https://docs.readthedocs.io/en/stable/guides/intersphinx.html\n        reftarget = reftarget.replace(replace, \"\")\n        if reftype == \"doc\":  # also need to replace the doc link\n            node.replace_attr(\"reftarget\", reftarget)\n        # Delegate to the ref node's original domain/target (typically :ref:)\n        try:\n            domain = app.env.domains[node[\"refdomain\"]]\n            return domain.resolve_xref(\n                app.env, refdoc, app.builder, reftype, reftarget, node, contnode\n            )\n        except Exception:\n            pass\n\n        # Otherwise return None which should delegate to intersphinx", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "As\n# an example, we'll generate 4 theoretical circular orbits at different\n# Galactocentric radii with the same circular velocity, and transform them to\n# Heliocentric coordinates:\n\nring_distances = np.arange(10, 25+1, 5) * u.kpc\ncirc_velocity = 220 * u.km/u.s\n\nphi_grid = np.linspace(90, 270, 512) * u.degree # grid of azimuths\nring_rep = coord.CylindricalRepresentation(\n    rho=ring_distances[:,np.newaxis],\n    phi=phi_grid[np.newaxis],\n    z=np.zeros_like(ring_distances)[:,np.newaxis])\n\nangular_velocity = (-circ_velocity / ring_distances).to(u.mas/u.yr,\n                                                        u.dimensionless_angles())\nring_dif = coord.CylindricalDifferential(\n    d_rho=np.zeros(phi_grid.shape)[np.newaxis]*u.km/u.s,\n    d_phi=angular_velocity[:,np.newaxis],\n    d_z=np.zeros(phi_grid.shape)[np.newaxis]*u.km/u.s\n)\n\nring_rep = ring_rep.with_differentials(ring_dif)\ngc_rings = coord.SkyCoord(ring_rep, frame=coord.Galactocentric)\n\n##############################################################################\n# First, let's visualize the geometry in Galactocentric coordinates.", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "import configparser\nimport doctest\nimport os\nimport sys\nfrom datetime import datetime\nfrom importlib import metadata\n\nfrom packaging.requirements import Requirement\nfrom packaging.specifiers import SpecifierSet\n\n# -- Check for missing dependencies -------------------------------------------\nmissing_requirements = {}\nfor line in metadata.requires(\"astropy\"):\n    if 'extra == \"docs\"' in line:\n        req = Requirement(line.split(\";\")[0])\n        req_package = req.name.lower()\n        req_specifier = str(req.specifier)\n\n        try:\n            version = metadata.version(req_package)\n        except metadata.PackageNotFoundError:\n            missing_requirements[req_package] = req_specifier\n\n        if version not in SpecifierSet(req_specifier, prereleases=True):\n            missing_requirements[req_package] = req_specifier\n\nif missing_requirements:\n    print(\n        \"The following packages could not be found and are required to \"\n        \"build the documentation:\"\n    )\n    for key, val in missing_requirements.items():\n        print(f\"    * {key} {val}\")\n    print('Please install the \"docs\" requirements.')\n    sys.exit(1)\n\nfrom sphinx_astropy.conf.v1 import *  # noqa: E402\nfrom sphinx_astropy.conf.v1 import (  # noqa: E402\n    exclude_patterns,\n    extensions,\n    intersphinx_mapping,\n    numpydoc_xref_aliases,\n    numpydoc_xref_astropy_aliases,\n    numpydoc_xref_ignore,\n    rst_epilog,\n)\n\n# -- Plot configuration -------------------------------------------------------\nplot_rcparams = {\n    \"axes.labelsize\": \"large\",\n    \"figure.figsize\": (6, 6),\n    \"figure.subplot.hspace\": 0.5,\n    \"savefig.bbox\": \"tight\",\n    \"savefig.facecolor\": \"none\",\n}\nplot_apply_rcparams = True\nplot_html_show_source_link = False\nplot_formats = [\"png\", \"svg\", \"pdf\"]\n# Don't use the default - which includes a numpy and matplotlib import\nplot_pre_code = \"\"\n\n# -- General configuration ----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = \"3.0\"\n\n# The intersphinx_mapping in sphinx_astropy.sphinx refers to astropy for\n# the benefit of other packages who want to refer to objects in the\n# astropy core.", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "\"\"\"\n================================================================\nConvert a radial velocity to the Galactic Standard of Rest (GSR)\n================================================================\n\nRadial or line-of-sight velocities of sources are often reported in a\nHeliocentric or Solar-system barycentric reference frame. A common\ntransformation incorporates the projection of the Sun's motion along the\nline-of-sight to the target, hence transforming it to a Galactic rest frame\ninstead (sometimes referred to as the Galactic Standard of Rest, GSR). This\ntransformation depends on the assumptions about the orientation of the Galactic\nframe relative to the bary- or Heliocentric frame. It also depends on the\nassumed solar velocity vector. Here we'll demonstrate how to perform this\ntransformation using a sky position and barycentric radial-velocity.\n\n\n*By: Adrian Price-Whelan*\n\n*License: BSD*", "metadata": {"file_name": "examples/coordinates/rv-to-gsr.py", "File Name": "examples/coordinates/rv-to-gsr.py", "Functions": "rv_to_gsr"}}, {"code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# This file needs to be included here to make sure commands such\n# as ``pytest docs/...`` works, since this\n# will ignore the conftest.py file at the root of the repository\n# and the one in astropy/conftest.py\n\nimport os\nimport tempfile\n\nimport pytest\n\n# Make sure we use temporary directories for the config and cache\n# so that the tests are insensitive to local configuration.\n\nos.environ[\"XDG_CONFIG_HOME\"] = tempfile.mkdtemp(\"astropy_config\")\nos.environ[\"XDG_CACHE_HOME\"] = tempfile.mkdtemp(\"astropy_cache\")\n\nos.mkdir(os.path.join(os.environ[\"XDG_CONFIG_HOME\"], \"astropy\"))\nos.mkdir(os.path.join(os.environ[\"XDG_CACHE_HOME\"], \"astropy\"))\n\n# Note that we don't need to change the environment variables back or remove\n# them after testing, because they are only changed for the duration of the\n# Python process, and this configuration only matters if running pytest\n# directly, not from e.g. an IPython session.\n\n\n@pytest.fixture(autouse=True)\ndef _docdir(request):\n    \"\"\"Run doctests in isolated tmp_path so outputs do not end up in repo.\"\"\"\n    # Trigger ONLY for doctestplus\n    doctest_plugin = request.config.pluginmanager.getplugin(\"doctestplus\")\n    if isinstance(request.node.parent, doctest_plugin._doctest_textfile_item_cls):\n        # Don't apply this fixture to io.rst.  It reads files and doesn't write.\n        # Implementation from https://github.com/pytest-dev/pytest/discussions/10437\n        if \"io.rst\" not in request.node.name:\n            old_cwd = os.getcwd()\n            tmp_path = request.getfixturevalue(\"tmp_path\")\n            os.chdir(tmp_path)\n            yield\n            os.chdir(old_cwd)\n        else:\n            yield\n    else:\n        yield", "metadata": {"file_name": "docs/conftest.py", "File Name": "docs/conftest.py", "Functions": "_docdir"}}, {"code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n#\n# Astropy documentation build configuration file.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this file.\n#\n# All configuration values have a default. Some values are defined in\n# the global Astropy configuration which is loaded here before anything else.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n# sys.path.insert(0, os.path.abspath('..'))\n# IMPORTANT: the above commented section was generated by sphinx-quickstart, but\n# is *NOT* appropriate for astropy or Astropy affiliated packages. It is left\n# commented out with this explanation to make it clear why this should not be\n# done. If the sys.path entry above is added, when the astropy.sphinx.conf\n# import occurs, it will import the *source* version of astropy instead of the\n# version installed (if invoked as \"make html\" or directly with sphinx), or the\n# version in the build directory.\n# Thus, any C-extensions that are needed to build the documentation will *not*\n# be accessible, and the documentation will not build correctly.\n# See sphinx_astropy.conf for which values are set there.", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "# -- Options for HTML output ---------------------------------------------------\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\nhtml_title = f\"{project} v{release}\"\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = project + \"doc\"\n\n# A dictionary of values to pass into the template engine's context for all pages.\nhtml_context = {\"to_be_indexed\": [\"stable\", \"latest\"], \"is_development\": dev}\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\nhtml_extra_path = [\"robots.txt\"]\n\n# -- Options for LaTeX output --------------------------------------------------\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    (\"index\", project + \".tex\", project + \" Documentation\", author, \"manual\")\n]\n\nlatex_logo = \"_static/astropy_logo.pdf\"", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "To make several modifications, it's better to load the file once:\n\nwith fits.open(fits_file, 'update') as f:\n    for hdu in f:\n        hdu.header['OBJECT'] = 'CAT'\n\nprint(\"After modifications:\")\nprint()\nprint(\"Extension 0:\")\nprint(repr(fits.getheader(fits_file, 0)))\nprint()\nprint(\"Extension 1:\")\nprint(repr(fits.getheader(fits_file, 1)))", "metadata": {"file_name": "examples/io/modify-fits-header.py", "File Name": "examples/io/modify-fits-header.py"}}, {"code": "# -- Options for linkcheck output -------------------------------------------\nlinkcheck_retry = 5\nlinkcheck_ignore = [\n    \"https://journals.aas.org/manuscript-preparation/\",\n    \"https://maia.usno.navy.mil/\",\n    \"https://www.usno.navy.mil/USNO/time/gps/usno-gps-time-transfer\",\n    \"https://aa.usno.navy.mil/publications/docs/Circular_179.php\",\n    \"http://data.astropy.org\",\n    \"https://doi.org/\",  # CI blocked by service provider\n    \"https://ui.adsabs.harvard.edu\",  # CI blocked by service provider\n    \"https://www.tandfonline.com/\",  # 403 Client Error: Forbidden\n    \"https://physics.nist.gov/\",  # SSL: CERTIFICATE_VERIFY_FAILED\n    \"https://ieeexplore.ieee.org/\",  # 418 Client Error: I'm a teapot\n    \"https://pyfits.readthedocs.io/en/v3.2.1/\",  # defunct page in CHANGES.rst\n    r\"https://github\\.com/astropy/astropy/(?:issues|pull)/\\d+\",\n]\nlinkcheck_timeout = 180\nlinkcheck_anchors = False\n\n\ndef rstjinja(app, docname, source):\n    \"\"\"Render pages as a jinja template to hide/show dev docs.\"\"\"\n    # Make sure we're outputting HTML\n    if app.builder.format != \"html\":\n        return\n    files_to_render = [\"index\", \"install\", \"development/index\"]\n    if docname in files_to_render:\n        print(f\"Jinja rendering {docname}\")\n        rendered = app.builder.templates.render_string(\n            source[0], app.config.html_context\n        )\n        source[0] = rendered", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "# NOTE: this hook should be added to\n# https://github.com/pyinstaller/pyinstaller-hooks-contrib\n# once that repository is ready for pull requests\nfrom PyInstaller.utils.hooks import collect_data_files\n\ndatas = collect_data_files(\"skyfield\")", "metadata": {"file_name": ".pyinstaller/hooks/hook-skyfield.py", "File Name": ".pyinstaller/hooks/hook-skyfield.py"}}], "traj": {"usage": {"embedding_tokens": 0}}}
{"instance_id": "astropy__astropy-14995", "found_files": ["examples/template/example-template.py", "docs/nddata/examples/cutout2d_tofits.py", "examples/io/skip_create-large-fits.py", ".pyinstaller/run_astropy_tests.py", "docs/conf.py", "examples/coordinates/plot_sgr-coordinate-frame.py", "examples/coordinates/plot_obs-planning.py", "examples/io/split-jpeg-to-fits.py", "examples/coordinates/rv-to-gsr.py", "docs/wcs/examples/programmatic.py", "examples/coordinates/plot_galactocentric-frame.py", "examples/io/create-mef.py", "docs/wcs/examples/from_file.py", "examples/io/modify-fits-header.py", "docs/wcs/examples/cube_wcs.py", "examples/io/fits-tables.py", "examples/io/plot_fits-image.py", "docs/conftest.py", ".pyinstaller/hooks/hook-skyfield.py"], "node_info": [{"code": "\"\"\"\n\n##############################################################################\n# Make print work the same in all versions of Python, set up numpy,\n# matplotlib, and use a nicer set of plot parameters:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom astropy.visualization import astropy_mpl_style\n\nplt.style.use(astropy_mpl_style)\n# uncomment if including figures:\n# import matplotlib.pyplot as plt\n# from astropy.visualization import astropy_mpl_style\n# plt.style.use(astropy_mpl_style)\n\n##############################################################################\n# This code block is executed, although it produces no output. Lines starting\n# with a simple hash are code comment and get treated as part of the code\n# block. To include this new comment string we started the new block with a\n# long line of hashes.\n#\n# The sphinx-gallery parser will assume everything after this splitter and that\n# continues to start with a **comment hash and space** (respecting code style)\n# is text that has to be rendered in\n# html format. Keep in mind to always keep your comments always together by\n# comment hashes. That means to break a paragraph you still need to comment\n# that line break.\n#\n# In this example the next block of code produces some plotable data. Code is\n# executed, figure is saved and then code is presented next, followed by the\n# inlined figure.\n\nx = np.linspace(-np.pi, np.pi, 300)\nxx, yy = np.meshgrid(x, x)\nz = np.cos(xx) + np.cos(yy)\n\nplt.figure()\nplt.imshow(z)\nplt.colorbar()\nplt.xlabel('$x$')\nplt.ylabel('$y$')\n\n###########################################################################\n# Again it is possible to continue the discussion with a new Python string. This\n# time to introduce the next code block generates 2 separate figures.\n\nplt.figure()\nplt.imshow(z, cmap=plt.cm.get_cmap('hot'))\nplt.figure()\nplt.imshow(z, cmap=plt.cm.get_cmap('Spectral'), interpolation='none')\n\n##########################################################################\n# There's some subtle differences between rendered html rendered comment\n# strings and code comment strings which I'll demonstrate below. (Some of this\n# only makes sense if you look at the\n# :download:`raw Python script <plot_notebook.py>`)\n#\n# Comments in comment blocks remain nested in the text.\n\n\ndef dummy():\n    \"\"\"Dummy function to make sure docstrings don't get rendered as text\"\"\"\n    pass", "metadata": {"file_name": "examples/template/example-template.py", "File Name": "examples/template/example-template.py", "Functions": "dummy"}}, {"code": "# Download an example FITS file, create a 2D cutout, and save it to a\n# new FITS file, including the updated cutout WCS.\nfrom astropy.io import fits\nfrom astropy.nddata import Cutout2D\nfrom astropy.utils.data import download_file\nfrom astropy.wcs import WCS\n\n\ndef download_image_save_cutout(url, position, size):\n    # Download the image\n    filename = download_file(url)\n\n    # Load the image and the WCS\n    hdu = fits.open(filename)[0]\n    wcs = WCS(hdu.header)\n\n    # Make the cutout, including the WCS\n    cutout = Cutout2D(hdu.data, position=position, size=size, wcs=wcs)\n\n    # Put the cutout image in the FITS HDU\n    hdu.data = cutout.data\n\n    # Update the FITS header with the cutout WCS\n    hdu.header.update(cutout.wcs.to_header())\n\n    # Write the cutout to a new FITS file\n    cutout_filename = 'example_cutout.fits'\n    hdu.writeto(cutout_filename, overwrite=True)\n\n\nif __name__ == '__main__':\n    url = 'https://astropy.stsci.edu/data/photometry/spitzer_example_image.fits'\n\n    position = (500, 300)\n    size = (400, 400)\n    download_image_save_cutout(url, position, size)", "metadata": {"file_name": "docs/nddata/examples/cutout2d_tofits.py", "File Name": "docs/nddata/examples/cutout2d_tofits.py", "Functions": "download_image_save_cutout"}}, {"code": "abs(header['BITPIX'])/8\n    # (this example is assuming a 64-bit float)\n    # The -1 is to account for the final byte that we are about to\n    # write:\n    fobj.seek(len(header.tostring()) + (40000 * 40000 * 8) - 1)\n    fobj.write(b'\\0')\n\n##############################################################################\n# More generally, this can be written:\n\nshape = tuple(header[f'NAXIS{ii}'] for ii in range(1, header['NAXIS']+1))\nwith open('large.fits', 'rb+') as fobj:\n    fobj.seek(len(header.tostring()) + (np.prod(shape) * np.abs(header['BITPIX']//8)) - 1)\n    fobj.write(b'\\0')\n\n##############################################################################\n# On modern operating systems this will cause the file (past the header) to be\n# filled with zeros out to the ~12GB needed to hold a 40000 x 40000 image. On\n# filesystems that support sparse file creation (most Linux filesystems, but not\n# the HFS+ filesystem used by most Macs) this is a very fast, efficient\n# operation. On other systems your mileage may vary.\n#\n# This isn't the only way to build up a large file, but probably one of the\n# safest. This method can also be used to create large multi-extension FITS\n# files, with a little care.\n\n##############################################################################\n# Finally, we'll remove the file we created:\n\nos.remove('large.fits')", "metadata": {"file_name": "examples/io/skip_create-large-fits.py", "File Name": "examples/io/skip_create-large-fits.py"}}, {"code": "os.remove(os.path.join(\"astropy_tests\", \"table\", \"mixins\", \"tests\", \"test_registry.py\"))\n\n# Copy the top-level conftest.py\nshutil.copy2(\n    os.path.join(ROOT, \"astropy\", \"conftest.py\"),\n    os.path.join(\"astropy_tests\", \"conftest.py\"),\n)\n\n# matplotlib hook in pyinstaller 5.0 and later no longer collects every backend, see\n# https://github.com/pyinstaller/pyinstaller/issues/6760\nmatplotlib.use(\"svg\")\n\n# We skip a few tests, which are generally ones that rely on explicitly\n# checking the name of the current module (which ends up starting with\n# astropy_tests rather than astropy).\n\nSKIP_TESTS = [\n    \"test_exception_logging_origin\",\n    \"test_log\",\n    \"test_configitem\",\n    \"test_config_noastropy_fallback\",\n    \"test_no_home\",\n    \"test_path\",\n    \"test_rename_path\",\n    \"test_data_name_third_party_package\",\n    \"test_pkg_finder\",\n    \"test_wcsapi_extension\",\n    \"test_find_current_module_bundle\",\n    \"test_minversion\",\n    \"test_imports\",\n    \"test_generate_config\",\n    \"test_generate_config2\",\n    \"test_create_config_file\",\n    \"test_download_parallel_fills_cache\",\n]\n\n# Run the tests!\nsys.exit(\n    pytest.main(\n        [\"astropy_tests\", \"-k \" + \" and \".join(\"not \" + test for test in SKIP_TESTS)],\n        plugins=[\n            \"pytest_astropy.plugin\",\n            \"pytest_doctestplus.plugin\",\n            \"pytest_remotedata.plugin\",\n            \"pytest_astropy_header.display\",\n        ],\n    )\n)", "metadata": {"file_name": ".pyinstaller/run_astropy_tests.py", "File Name": ".pyinstaller/run_astropy_tests.py"}}, {"code": "# so here we mostly need to define Astropy-specific x-refs\nnumpydoc_xref_aliases.update(\n    {\n        # python & adjacent\n        \"Any\": \"`~typing.Any`\",\n        \"file-like\": \":term:`python:file-like object`\",\n        \"file\": \":term:`python:file object`\",\n        \"path-like\": \":term:`python:path-like object`\",\n        \"module\": \":term:`python:module`\",\n        \"buffer-like\": \":term:buffer-like\",\n        \"hashable\": \":term:`python:hashable`\",\n        # for matplotlib\n        \"color\": \":term:`color`\",\n        # for numpy\n        \"ints\": \":class:`python:int`\",\n        # for astropy\n        \"number\": \":term:`number`\",\n        \"Representation\": \":class:`~astropy.coordinates.BaseRepresentation`\",\n        \"writable\": \":term:`writable file-like object`\",\n        \"readable\": \":term:`readable file-like object`\",\n        \"BaseHDU\": \":doc:`HDU </io/fits/api/hdus>`\",\n    }\n)\n# Add from sphinx-astropy 1) glossary aliases 2) physical types.\nnumpydoc_xref_aliases.update(numpydoc_xref_astropy_aliases)\n\n# Turn off table of contents entries for functions and classes\ntoc_object_entries = False\n\n# -- Project information ------------------------------------------------------\n\nproject = \"Astropy\"\nauthor = \"The Astropy Developers\"\ncopyright = f\"2011\u2013{datetime.utcnow().year}, \" + author\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n\n# The full version, including alpha/beta/rc tags.\nrelease = metadata.version(project)\n# The short X.Y version.\nversion = \".\".join(release.split(\".\")[:2])\n\n# Only include dev docs in dev version.\ndev = \"dev\" in release\nif not dev:\n    exclude_patterns += [\"development/*\", \"testhelpers.rst\"]\n\n# -- Options for the module index ---------------------------------------------\n\nmodindex_common_prefix = [\"astropy.\"]", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "import os\nimport shutil\nimport sys\n\nimport erfa  # noqa: F401\nimport matplotlib\nimport pytest\n\nimport astropy  # noqa: F401\n\nif len(sys.argv) == 3 and sys.argv[1] == \"--astropy-root\":\n    ROOT = sys.argv[2]\nelse:\n    # Make sure we don't allow any arguments to be passed - some tests call\n    # sys.executable which becomes this script when producing a pyinstaller\n    # bundle, but we should just error in this case since this is not the\n    # regular Python interpreter.\n    if len(sys.argv) > 1:\n        print(\"Extra arguments passed, exiting early\")\n        sys.exit(1)\n\nfor root, dirnames, files in os.walk(os.path.join(ROOT, \"astropy\")):\n    # NOTE: we can't simply use\n    # test_root = root.replace('astropy', 'astropy_tests')\n    # as we only want to change the one which is for the module, so instead\n    # we search for the last occurrence and replace that.\n    pos = root.rfind(\"astropy\")\n    test_root = root[:pos] + \"astropy_tests\" + root[pos + 7 :]\n\n    # Copy over the astropy 'tests' directories and their contents\n    for dirname in dirnames:\n        final_dir = os.path.relpath(os.path.join(test_root, dirname), ROOT)\n        # We only copy over 'tests' directories, but not astropy/tests (only\n        # astropy/tests/tests) since that is not just a directory with tests.\n        if dirname == \"tests\" and not root.endswith(\"astropy\"):\n            shutil.copytree(os.path.join(root, dirname), final_dir, dirs_exist_ok=True)\n        else:\n            # Create empty __init__.py files so that 'astropy_tests' still\n            # behaves like a single package, otherwise pytest gets confused\n            # by the different conftest.py files.", "metadata": {"file_name": ".pyinstaller/run_astropy_tests.py", "File Name": ".pyinstaller/run_astropy_tests.py"}}, {"code": "##############################################################################\n# The decorator ``@frame_transform_graph.transform(coord.StaticMatrixTransform,\n# coord.Galactic, Sagittarius)``  registers this function on the\n# ``frame_transform_graph`` as a coordinate transformation. Inside the function,\n# we simply return the previously defined rotation matrix.\n#\n# We then register the inverse transformation by using the transpose of the\n# rotation matrix (which is faster to compute than the inverse):\n\n@frame_transform_graph.transform(coord.StaticMatrixTransform, Sagittarius, coord.Galactic)\ndef sgr_to_galactic():\n    \"\"\"Compute the heliocentric Sgr to spherical Galactic transformation matrix.\"\"\"\n    return matrix_transpose(SGR_MATRIX)\n\n\n##############################################################################\n# Now that we've registered these transformations between ``Sagittarius`` and\n# `~astropy.coordinates.Galactic`, we can transform between *any* coordinate\n# system and ``Sagittarius`` (as long as the other system has a path to\n# transform to `~astropy.coordinates.Galactic`). For example, to transform from\n# ICRS coordinates to ``Sagittarius``, we would do:\n\nicrs = coord.SkyCoord(280.161732*u.degree, 11.91934*u.degree, frame='icrs')\nsgr = icrs.transform_to(Sagittarius)\nprint(sgr)\n\n##############################################################################\n# Or, to transform from the ``Sagittarius`` frame to ICRS coordinates (in this\n# case, a line along the ``Sagittarius`` x-y plane):\n\nsgr = coord.SkyCoord(Lambda=np.linspace(0, 2*np.pi, 128)*u.radian,\n                     Beta=np.zeros(128)*u.radian, frame='sagittarius')\nicrs = sgr.transform_to(coord.ICRS)\nprint(icrs)\n\n##############################################################################\n# As an example, we'll now plot the points in both coordinate systems:\n\nfig, axes = plt.subplots(2, 1, figsize=(8, 10),\n                         subplot_kw={'projection': 'aitoff'})\n\naxes[0].set_title(\"Sagittarius\")\naxes[0].plot(sgr.Lambda.wrap_at(180*u.deg).radian, sgr.Beta.radian,\n             linestyle='none', marker='.')", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "#\n# Create a stub array to initialize the HDU; its\n# exact size is irrelevant, as long as it has the desired number of\n# dimensions\n\ndata = np.zeros((100, 100), dtype=np.float64)\nhdu = fits.PrimaryHDU(data=data)\nheader = hdu.header\nwhile len(header) < (36 * 4 - 1):\n    header.append()  # Adds a blank card to the end\n\n##############################################################################\n# Now adjust the NAXISn keywords to the desired size of the array, and write\n# only the header out to a file. Using the ``hdu.writeto()`` method will cause\n# astropy to \"helpfully\" reset the NAXISn keywords to match the size of the\n# dummy array. That is because it works hard to ensure that only valid FITS\n# files are written. Instead, we can write just the header to a file using the\n# `astropy.io.fits.Header.tofile` method:\n\nheader['NAXIS1'] = 40000\nheader['NAXIS2'] = 40000\nheader.tofile('large.fits')\n\n##############################################################################\n# Finally, grow out the end of the file to match the length of the\n# data (plus the length of the header). This can be done very efficiently on\n# most systems by seeking past the end of the file and writing a single byte,\n# like so:\n\nwith open('large.fits', 'rb+') as fobj:\n    # Seek past the length of the header, plus the length of the\n    # Data we want to write.\n    # 8 is the number of bytes per value, i.e.", "metadata": {"file_name": "examples/io/skip_create-large-fits.py", "File Name": "examples/io/skip_create-large-fits.py"}}, {"code": "#\n# Find the alt,az coordinates of M33 at 100 times evenly spaced between 10pm\n# and 7am EDT:\n\nmidnight = Time('2012-7-13 00:00:00') - utcoffset\ndelta_midnight = np.linspace(-2, 10, 100)*u.hour\nframe_July13night = AltAz(obstime=midnight+delta_midnight,\n                          location=bear_mountain)\nm33altazs_July13night = m33.transform_to(frame_July13night)\n\n##############################################################################\n# convert alt, az to airmass with `~astropy.coordinates.AltAz.secz` attribute:\n\nm33airmasss_July13night = m33altazs_July13night.secz\n\n##############################################################################\n# Plot the airmass as a function of time:\n\nplt.plot(delta_midnight, m33airmasss_July13night)\nplt.xlim(-2, 10)\nplt.ylim(1, 4)\nplt.xlabel('Hours from EDT Midnight')\nplt.ylabel('Airmass [Sec(z)]')\nplt.show()\n\n##############################################################################\n# Use  `~astropy.coordinates.get_sun` to find the location of the Sun at 1000\n# evenly spaced times between noon on July 12 and noon on July 13:\n\nfrom astropy.coordinates import get_sun\n\ndelta_midnight = np.linspace(-12, 12, 1000)*u.hour\ntimes_July12_to_13 = midnight + delta_midnight\nframe_July12_to_13 = AltAz(obstime=times_July12_to_13, location=bear_mountain)\nsunaltazs_July12_to_13 = get_sun(times_July12_to_13).transform_to(frame_July12_to_13)", "metadata": {"file_name": "examples/coordinates/plot_obs-planning.py", "File Name": "examples/coordinates/plot_obs-planning.py"}}, {"code": "with open(\"common_links.txt\") as cl:\n    rst_epilog += cl.read().format(\n        minimum_python=__minimum_python_version__, **min_versions\n    )\n\n# Manually register doctest options since matplotlib 3.5 messed up allowing them\n# from pytest-doctestplus\nIGNORE_OUTPUT = doctest.register_optionflag(\"IGNORE_OUTPUT\")\nREMOTE_DATA = doctest.register_optionflag(\"REMOTE_DATA\")\nFLOAT_CMP = doctest.register_optionflag(\"FLOAT_CMP\")\n\n# Whether to create cross-references for the parameter types in the\n# Parameters, Other Parameters, Returns and Yields sections of the docstring.\nnumpydoc_xref_param_type = True\n\n# Words not to cross-reference. Most likely, these are common words used in\n# parameter type descriptions that may be confused for classes of the same\n# name. The base set comes from sphinx-astropy. We add more here.\nnumpydoc_xref_ignore.update(\n    {\n        \"mixin\",\n        \"Any\",  # aka something that would be annotated with `typing.Any`\n        # needed in subclassing numpy  # TODO! revisit\n        \"Arguments\",\n        \"Path\",\n        # TODO! not need to ignore.\n        \"flag\",\n        \"bits\",\n    }\n)\n\n# Mappings to fully qualified paths (or correct ReST references) for the\n# aliases/shortcuts used when specifying the types of parameters.\n# Numpy provides some defaults\n# https://github.com/numpy/numpydoc/blob/b352cd7635f2ea7748722f410a31f937d92545cc/numpydoc/xref.py#L62-L94\n# and a base set comes from sphinx-astropy.", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "\"\"\"\n=====================================================\nConvert a 3-color image (JPG) to separate FITS images\n=====================================================\n\nThis example opens an RGB JPEG image and writes out each channel as a separate\nFITS (image) file.\n\nThis example uses `pillow <https://python-pillow.org>`_ to read the image,\n`matplotlib.pyplot` to display the image, and `astropy.io.fits` to save FITS files.\n\n\n*By: Erik Bray, Adrian Price-Whelan*\n\n*License: BSD*", "metadata": {"file_name": "examples/io/split-jpeg-to-fits.py", "File Name": "examples/io/split-jpeg-to-fits.py"}}, {"code": "\"\"\"\n\n##############################################################################\n# Make `print` work the same in all versions of Python, set up numpy,\n# matplotlib, and use a nicer set of plot parameters:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom astropy.visualization import astropy_mpl_style\n\nplt.style.use(astropy_mpl_style)\n\n\n##############################################################################\n# Import the packages necessary for coordinates\n\nimport astropy.coordinates as coord\nimport astropy.units as u\nfrom astropy.coordinates import frame_transform_graph\nfrom astropy.coordinates.matrix_utilities import matrix_transpose, rotation_matrix\n\n##############################################################################\n# The first step is to create a new class, which we'll call\n# ``Sagittarius`` and make it a subclass of\n# `~astropy.coordinates.BaseCoordinateFrame`:", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "axes[1].set_title(\"ICRS\")\naxes[1].plot(icrs.ra.wrap_at(180*u.deg).radian, icrs.dec.radian,\n             linestyle='none', marker='.')\n\nplt.show()\n\n##############################################################################\n# This particular transformation is just a spherical rotation, which is a\n# special case of an Affine transformation with no vector offset. The\n# transformation of velocity components is therefore natively supported as\n# well:\n\nsgr = coord.SkyCoord(Lambda=np.linspace(0, 2*np.pi, 128)*u.radian,\n                     Beta=np.zeros(128)*u.radian,\n                     pm_Lambda_cosBeta=np.random.uniform(-5, 5, 128)*u.mas/u.yr,\n                     pm_Beta=np.zeros(128)*u.mas/u.yr,\n                     frame='sagittarius')\nicrs = sgr.transform_to(coord.ICRS)\nprint(icrs)\n\nfig, axes = plt.subplots(3, 1, figsize=(8, 10), sharex=True)\n\naxes[0].set_title(\"Sagittarius\")\naxes[0].plot(sgr.Lambda.degree,\n             sgr.pm_Lambda_cosBeta.value,\n             linestyle='none', marker='.')\naxes[0].set_xlabel(r\"$\\Lambda$ [deg]\")\naxes[0].set_ylabel(\n    fr\"$\\mu_\\Lambda \\, \\cos B$ [{sgr.pm_Lambda_cosBeta.unit.to_string('latex_inline')}]\")\n\naxes[1].set_title(\"ICRS\")\naxes[1].plot(icrs.ra.degree, icrs.pm_ra_cosdec.value,\n             linestyle='none', marker='.')\naxes[1].set_ylabel(\n    fr\"$\\mu_\\alpha \\, \\cos\\delta$ [{icrs.pm_ra_cosdec.unit.to_string('latex_inline')}]\")\n\naxes[2].set_title(\"ICRS\")\naxes[2].plot(icrs.ra.degree, icrs.pm_dec.value,\n             linestyle='none', marker='.')\naxes[2].set_xlabel(\"RA [deg]\")\naxes[2].set_ylabel(\n    fr\"$\\mu_\\delta$ [{icrs.pm_dec.unit.to_string('latex_inline')}]\")\n\nplt.show()", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "################################################################################\n# We could wrap this in a function so we can control the solar velocity and\n# re-use the above code:\ndef rv_to_gsr(c, v_sun=None):\n    \"\"\"Transform a barycentric radial velocity to the Galactic Standard of Rest\n    (GSR).\n\n    The input radial velocity must be passed in as a\n\n    Parameters\n    ----------\n    c : `~astropy.coordinates.BaseCoordinateFrame` subclass instance\n        The radial velocity, associated with a sky coordinates, to be\n        transformed.\n    v_sun : `~astropy.units.Quantity`, optional\n        The 3D velocity of the solar system barycenter in the GSR frame.\n        Defaults to the same solar motion as in the\n        `~astropy.coordinates.Galactocentric` frame.\n\n    Returns\n    -------\n    v_gsr : `~astropy.units.Quantity`\n        The input radial velocity transformed to a GSR frame.\n\n    \"\"\"\n    if v_sun is None:\n        v_sun = coord.Galactocentric().galcen_v_sun.to_cartesian()\n\n    gal = c.transform_to(coord.Galactic)\n    cart_data = gal.data.to_cartesian()\n    unit_vector = cart_data / cart_data.norm()\n\n    v_proj = v_sun.dot(unit_vector)\n\n    return c.radial_velocity + v_proj\n\n\nrv_gsr = rv_to_gsr(icrs)\nprint(rv_gsr)", "metadata": {"file_name": "examples/coordinates/rv-to-gsr.py", "File Name": "examples/coordinates/rv-to-gsr.py", "Functions": "rv_to_gsr"}}, {"code": "# Set the WCS information manually by setting properties of the WCS\n# object.\n\nimport numpy as np\n\nfrom astropy import wcs\nfrom astropy.io import fits\n\n# Create a new WCS object.  The number of axes must be set\n# from the start\nw = wcs.WCS(naxis=2)\n\n# Set up an \"Airy's zenithal\" projection\n# Vector properties may be set with Python lists, or Numpy arrays\nw.wcs.crpix = [-234.75, 8.3393]\nw.wcs.cdelt = np.array([-0.066667, 0.066667])\nw.wcs.crval = [0, -90]\nw.wcs.ctype = [\"RA---AIR\", \"DEC--AIR\"]\nw.wcs.set_pv([(2, 1, 45.0)])\n\n# Three pixel coordinates of interest.\n# The pixel coordinates are pairs of [X, Y].\n# The \"origin\" argument indicates whether the input coordinates\n# are 0-based (as in Numpy arrays) or\n# 1-based (as in the FITS convention, for example coordinates\n# coming from DS9).\npixcrd = np.array([[0, 0], [24, 38], [45, 98]], dtype=np.float64)\n\n# Convert pixel coordinates to world coordinates.\n# The second argument is \"origin\" -- in this case we're declaring we\n# have 0-based (Numpy-like) coordinates.\nworld = w.wcs_pix2world(pixcrd, 0)\nprint(world)\n\n# Convert the same coordinates back to pixel coordinates.\npixcrd2 = w.wcs_world2pix(world, 0)\nprint(pixcrd2)\n\n# These should be the same as the original pixel coordinates, modulo\n# some floating-point error.\nassert np.max(np.abs(pixcrd - pixcrd2)) < 1e-6\n\n# The example below illustrates the use of \"origin\" to convert between\n# 0- and 1- based coordinates when executing the forward and backward\n# WCS transform.", "metadata": {"file_name": "docs/wcs/examples/programmatic.py", "File Name": "docs/wcs/examples/programmatic.py"}}, {"code": "\"\"\"\n===================================================================\nDetermining and plotting the altitude/azimuth of a celestial object\n===================================================================\n\nThis example demonstrates coordinate transformations and the creation of\nvisibility curves to assist with observing run planning.\n\nIn this example, we make a `~astropy.coordinates.SkyCoord` instance for M33.\nThe altitude-azimuth coordinates are then found using\n`astropy.coordinates.EarthLocation` and `astropy.time.Time` objects.\n\nThis example is meant to demonstrate the capabilities of the\n`astropy.coordinates` package. For more convenient and/or complex observation\nplanning, consider the `astroplan <https://astroplan.readthedocs.org/>`_\npackage.\n\n\n*By: Erik Tollerud, Kelle Cruz*\n\n*License: BSD*\n\n\n\"\"\"\n\n##############################################################################\n# Let's suppose you are planning to visit picturesque Bear Mountain State Park\n# in New York, USA. You're bringing your telescope with you (of course), and\n# someone told you M33 is a great target to observe there. You happen to know\n# you're free at 11:00 pm local time, and you want to know if it will be up.\n# Astropy can answer that.\n#\n# Import numpy and matplotlib. For the latter, use a nicer set of plot\n# parameters and set up support for plotting/converting quantities.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom astropy.visualization import astropy_mpl_style, quantity_support\n\nplt.style.use(astropy_mpl_style)\nquantity_support()\n\n\n##############################################################################\n# Import the packages necessary for finding coordinates and making\n# coordinate transformations\n\nimport astropy.units as u\nfrom astropy.coordinates import AltAz, EarthLocation, SkyCoord\nfrom astropy.time import Time\n\n##############################################################################\n# `astropy.coordinates.SkyCoord.from_name` uses Simbad to resolve object\n# names and retrieve coordinates.", "metadata": {"file_name": "examples/coordinates/plot_obs-planning.py", "File Name": "examples/coordinates/plot_obs-planning.py"}}, {"code": "However, we don't want to cyclically reference astropy in its\n# own build so we remove it here.\ndel intersphinx_mapping[\"astropy\"]\n\n# add any custom intersphinx for astropy\nintersphinx_mapping.update(\n    {\n        \"astropy-dev\": (\"https://docs.astropy.org/en/latest/\", None),\n        \"pyerfa\": (\"https://pyerfa.readthedocs.io/en/stable/\", None),\n        \"pytest\": (\"https://docs.pytest.org/en/stable/\", None),\n        \"ipython\": (\"https://ipython.readthedocs.io/en/stable/\", None),\n        \"pandas\": (\"https://pandas.pydata.org/pandas-docs/stable/\", None),\n        \"sphinx_automodapi\": (\n            \"https://sphinx-automodapi.readthedocs.io/en/stable/\",\n            None,\n        ),\n        \"asdf-astropy\": (\"https://asdf-astropy.readthedocs.io/en/latest/\", None),\n        \"fsspec\": (\"https://filesystem-spec.readthedocs.io/en/latest/\", None),\n    }\n)\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# .inc.rst mean *include* files, don't have sphinx process them\nexclude_patterns += [\"_templates\", \"changes\", \"_pkgtemplate.rst\", \"**/*.inc.rst\"]\n\n# Add any paths that contain templates here, relative to this directory.\nif \"templates_path\" not in locals():  # in case parent conf.py defines it\n    templates_path = []\ntemplates_path.append(\"_templates\")\n\nextensions += [\"sphinx_changelog\"]\n\n# Grab minversion from setup.cfg\nsetup_cfg = configparser.ConfigParser()\nsetup_cfg.read(os.path.join(os.path.pardir, \"setup.cfg\"))\n__minimum_python_version__ = setup_cfg[\"options\"][\"python_requires\"].replace(\">=\", \"\")\n\nmin_versions = {}\nfor line in metadata.requires(\"astropy\"):\n    req = Requirement(line.split(\";\")[0])\n    min_versions[req.name.lower()] = str(req.specifier)\n\n\n# This is added to the end of RST files - a good place to put substitutions to\n# be used globally.", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "\"\"\"\n========================\nTitle of Example\n========================\n\nThis example <verb> <active tense> <does something>.\n\nThe example uses <packages> to <do something> and <other package> to <do other\nthing>. Include links to referenced packages like this: `astropy.io.fits` to\nshow the astropy.io.fits or like this `~astropy.io.fits`to show just 'fits'\n\n\n*By: <names>*\n\n*License: BSD*", "metadata": {"file_name": "examples/template/example-template.py", "File Name": "examples/template/example-template.py", "Functions": "dummy"}}, {"code": "\"\"\"\n==========================================\nCreate a very large FITS file from scratch\n==========================================\n\nThis example demonstrates how to create a large file (larger than will fit in\nmemory) from scratch using `astropy.io.fits`.\n\n\n*By: Erik Bray*\n\n*License: BSD*\n\n\"\"\"\n\n##############################################################################\n#  Normally to create a single image FITS file one would do something like:\n\nimport os\n\nimport numpy as np\n\nfrom astropy.io import fits\n\ndata = np.zeros((40000, 40000), dtype=np.float64)\nhdu = fits.PrimaryHDU(data=data)\n\n##############################################################################\n# Then use the `astropy.io.fits.writeto()` method to write out the new\n# file to disk\n\nhdu.writeto('large.fits')\n\n##############################################################################\n# However, a 40000 x 40000 array of doubles is nearly twelve gigabytes! Most\n# systems won't be able to create that in memory just to write out to disk. In\n# order to create such a large file efficiently requires a little extra work,\n# and a few assumptions.\n#\n# First, it is helpful to anticipate about how large (as in, how many keywords)\n# the header will have in it. FITS headers must be written in 2880 byte\n# blocks, large enough for 36 keywords per block (including the END keyword in\n# the final block). Typical headers have somewhere between 1 and 4 blocks,\n# though sometimes more.\n#\n# Since the first thing we write to a FITS file is the header, we want to write\n# enough header blocks so that there is plenty of padding in which to add new\n# keywords without having to resize the whole file. Say you want the header to\n# use 4 blocks by default. Then, excluding the END card which Astropy will add\n# automatically, create the header and pad it out to 36 * 4 cards.", "metadata": {"file_name": "examples/io/skip_create-large-fits.py", "File Name": "examples/io/skip_create-large-fits.py"}}, {"code": "Note that, as with the positions,\n# the Galactocentric frame is a right-handed system (i.e., the Sun is at negative\n# x values) so ``v_x`` is opposite of the Galactocentric radial velocity:\n\nv_sun = [11.1, 244, 7.25] * (u.km / u.s)  # [vx, vy, vz]\ngc_frame = coord.Galactocentric(\n    galcen_distance=8*u.kpc,\n    galcen_v_sun=v_sun,\n    z_sun=0*u.pc)\n\n##############################################################################\n# We can then transform to this frame instead, with our custom parameters:\n\ngc2 = c1.transform_to(gc_frame)\nprint(gc2.v_x, gc2.v_y, gc2.v_z)\n\n##############################################################################\n# It's sometimes useful to specify the solar motion using the `proper motion\n# of Sgr A* <https://arxiv.org/abs/astro-ph/0408107>`_ instead of Cartesian\n# velocity components. With an assumed distance, we can convert proper motion\n# components to Cartesian velocity components using `astropy.units`:\n\ngalcen_distance = 8*u.kpc\npm_gal_sgrA = [-6.379, -0.202] * u.mas/u.yr # from Reid & Brunthaler 2004\nvy, vz = -(galcen_distance * pm_gal_sgrA).to(u.km/u.s, u.dimensionless_angles())\n\n##############################################################################\n# We still have to assume a line-of-sight velocity for the Galactic center,\n# which we will again take to be 11 km/s:\nvx = 11.1 * u.km/u.s\nv_sun2 = u.Quantity([vx, vy, vz])  # List of Quantity -> a single Quantity\n\ngc_frame2 = coord.Galactocentric(galcen_distance=galcen_distance,\n                                 galcen_v_sun=v_sun2,\n                                 z_sun=0*u.pc)\ngc3 = c1.transform_to(gc_frame2)\nprint(gc3.v_x, gc3.v_y, gc3.v_z)\n\n##############################################################################\n# The transformations also work in the opposite direction. This can be useful\n# for transforming simulated or theoretical data to observable quantities.", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "\"\"\"\n=====================================================\nCreate a multi-extension FITS (MEF) file from scratch\n=====================================================\n\nThis example demonstrates how to create a multi-extension FITS (MEF)\nfile from scratch using `astropy.io.fits`.\n\n\n*By: Erik Bray*\n\n*License: BSD*\n\n\n\"\"\"\n\nimport os\n\nfrom astropy.io import fits\n\n##############################################################################\n# HDUList objects are used to hold all the HDUs in a FITS file. This\n# ``HDUList`` class is a subclass of Python's builtin `list` and can be\n# created from scratch. For example, to create a FITS file with\n# three extensions:\n\nnew_hdul = fits.HDUList()\nnew_hdul.append(fits.ImageHDU())\nnew_hdul.append(fits.ImageHDU())\n\n##############################################################################\n# Write out the new file to disk:\n\nnew_hdul.writeto('test.fits')\n\n##############################################################################\n# Alternatively, the HDU instances can be created first (or read from an\n# existing FITS file).\n#\n# Create a multi-extension FITS file with two empty IMAGE extensions (a\n# default PRIMARY HDU is prepended automatically if one is not specified;\n# we use ``overwrite=True`` to overwrite the file if it already exists):\n\nhdu1 = fits.PrimaryHDU()\nhdu2 = fits.ImageHDU()\nnew_hdul = fits.HDUList([hdu1, hdu2])\nnew_hdul.writeto('test.fits', overwrite=True)\n\n##############################################################################\n# Finally, we'll remove the file we created:\n\nos.remove('test.fits')", "metadata": {"file_name": "examples/io/create-mef.py", "File Name": "examples/io/create-mef.py"}}, {"code": "def load_wcs_from_file(filename):\n    # Load the FITS hdulist using astropy.io.fits\n    hdulist = fits.open(filename)\n\n    # Parse the WCS keywords in the primary HDU\n    w = wcs.WCS(hdulist[0].header)\n\n    # Print out the \"name\" of the WCS, as defined in the FITS header\n    print(w.wcs.name)\n\n    # Print out all of the settings that were parsed from the header\n    w.wcs.print_contents()\n\n    # Three pixel coordinates of interest.\n    # Note we've silently assumed an NAXIS=2 image here.\n    # The pixel coordinates are pairs of [X, Y].\n    # The \"origin\" argument indicates whether the input coordinates\n    # are 0-based (as in Numpy arrays) or\n    # 1-based (as in the FITS convention, for example coordinates\n    # coming from DS9).\n    pixcrd = np.array([[0, 0], [24, 38], [45, 98]], dtype=np.float64)\n\n    # Convert pixel coordinates to world coordinates\n    # The second argument is \"origin\" -- in this case we're declaring we\n    # have 0-based (Numpy-like) coordinates.\n    world = w.wcs_pix2world(pixcrd, 0)\n    print(world)\n\n    # Convert the same coordinates back to pixel coordinates.\n    pixcrd2 = w.wcs_world2pix(world, 0)\n    print(pixcrd2)\n\n    # These should be the same as the original pixel coordinates, modulo\n    # some floating-point error.\n    assert np.max(np.abs(pixcrd - pixcrd2)) < 1e-6\n\n    # The example below illustrates the use of \"origin\" to convert between\n    # 0- and 1- based coordinates when executing the forward and backward\n    # WCS transform.\n    x = 0\n    y = 0\n    origin = 0\n    assert (w.wcs_pix2world(x, y, origin) ==\n            w.wcs_pix2world(x + 1, y + 1, origin + 1))\n\n\nif __name__ == '__main__':\n    load_wcs_from_file(sys.argv[-1])", "metadata": {"file_name": "docs/wcs/examples/from_file.py", "File Name": "docs/wcs/examples/from_file.py", "Functions": "load_wcs_from_file"}}, {"code": "\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom PIL import Image\n\nfrom astropy.io import fits\nfrom astropy.visualization import astropy_mpl_style\n\n##############################################################################\n# Set up matplotlib and use a nicer set of plot parameters\n\nplt.style.use(astropy_mpl_style)\n\n##############################################################################\n# Load and display the original 3-color jpeg image:\n\nimage = Image.open('Hs-2009-14-a-web.jpg')\nxsize, ysize = image.size\nprint(f\"Image size: {ysize} x {xsize}\")\nprint(f\"Image bands: {image.getbands()}\")\nax = plt.imshow(image)\n\n##############################################################################\n# Split the three channels (RGB) and get the data as Numpy arrays. The arrays\n# are flattened, so they are 1-dimensional:\n\nr, g, b = image.split()\nr_data = np.array(r.getdata()) # data is now an array of length ysize*xsize\ng_data = np.array(g.getdata())\nb_data = np.array(b.getdata())\nprint(r_data.shape)\n\n##############################################################################\n# Reshape the image arrays to be 2-dimensional:\n\nr_data = r_data.reshape(ysize, xsize) # data is now a matrix (ysize, xsize)\ng_data = g_data.reshape(ysize, xsize)\nb_data = b_data.reshape(ysize, xsize)\nprint(r_data.shape)\n\n##############################################################################\n# Write out the channels as separate FITS images.\n# Add and visualize header info\n\nred = fits.PrimaryHDU(data=r_data)\nred.header['LATOBS'] = \"32:11:56\" # add spurious header info\nred.header['LONGOBS'] = \"110:56\"\nred.writeto('red.fits')\n\ngreen = fits.PrimaryHDU(data=g_data)\ngreen.header['LATOBS'] = \"32:11:56\"\ngreen.header['LONGOBS'] = \"110:56\"\ngreen.writeto('green.fits')\n\nblue = fits.PrimaryHDU(data=b_data)\nblue.header['LATOBS'] = \"32:11:56\"\nblue.header['LONGOBS'] = \"110:56\"\nblue.writeto('blue.fits')\n\nfrom pprint import pprint\n\npprint(red.header)\n\n##############################################################################\n# Delete the files created\n\nimport os\n\nos.remove('red.fits')\nos.remove('green.fits')\nos.remove('blue.fits')", "metadata": {"file_name": "examples/io/split-jpeg-to-fits.py", "File Name": "examples/io/split-jpeg-to-fits.py"}}, {"code": "# Code comments not preceded by the hash splitter are left in code blocks.\n\nstring = \"\"\"\nTriple-quoted string which tries to break parser but doesn't.\n\"\"\"\n\n############################################################################\n# Output of the script is captured:\n\nprint('Some output from Python')\n\n############################################################################\n# Finally, I'll call ``show`` at the end just so someone running the Python\n# code directly will see the plots; this is not necessary for creating the docs\n\nplt.show()", "metadata": {"file_name": "examples/template/example-template.py", "File Name": "examples/template/example-template.py", "Functions": "dummy"}}, {"code": "##############################################################################\n# Breaking this down line-by-line, we define the class as a subclass of\n# `~astropy.coordinates.BaseCoordinateFrame`. Then we include a descriptive\n# docstring.  The final lines are class-level attributes that specify the\n# default representation for the data, default differential for the velocity\n# information, and mappings from the attribute names used by representation\n# objects to the names that are to be used by the ``Sagittarius`` frame. In this\n# case we override the names in the spherical representations but don't do\n# anything with other representations like cartesian or cylindrical.\n#\n# Next we have to define the transformation from this coordinate system to some\n# other built-in coordinate system; we will use Galactic coordinates. We can do\n# this by defining functions that return transformation matrices, or by simply\n# defining a function that accepts a coordinate and returns a new coordinate in\n# the new system. Because the transformation to the Sagittarius coordinate\n# system is just a spherical rotation from Galactic coordinates, we'll just\n# define a function that returns this matrix. We'll start by constructing the\n# transformation matrix using pre-determined Euler angles and the\n# ``rotation_matrix`` helper function:\n\nSGR_PHI = (180 + 3.75) * u.degree # Euler angles (from Law & Majewski 2010)\nSGR_THETA = (90 - 13.46) * u.degree\nSGR_PSI = (180 + 14.111534) * u.degree\n\n# Generate the rotation matrix using the x-convention (see Goldstein)\nSGR_MATRIX = (\n    np.diag([1.,1.,-1.])\n    @ rotation_matrix(SGR_PSI, \"z\")\n    @ rotation_matrix(SGR_THETA, \"x\")\n    @ rotation_matrix(SGR_PHI, \"z\")\n)\n\n\n##############################################################################\n# Since we already constructed the transformation (rotation) matrix above, and\n# the inverse of a rotation matrix is just its transpose, the required\n# transformation functions are very simple:\n\n@frame_transform_graph.transform(coord.StaticMatrixTransform, coord.Galactic, Sagittarius)\ndef galactic_to_sgr():\n    \"\"\"Compute the Galactic spherical to heliocentric Sgr transformation matrix.\"\"\"\n    return SGR_MATRIX", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "init_filename = os.path.join(final_dir, \"__init__.py\")\n            if not os.path.exists(os.path.join(final_dir, \"__init__.py\")):\n                os.makedirs(final_dir, exist_ok=True)\n                with open(os.path.join(final_dir, \"__init__.py\"), \"w\") as f:\n                    f.write(\"#\")\n    # Copy over all conftest.py files\n    for file in files:\n        if file == \"conftest.py\":\n            final_file = os.path.relpath(os.path.join(test_root, file), ROOT)\n            shutil.copy2(os.path.join(root, file), final_file)\n\n# Add the top-level __init__.py file\nwith open(os.path.join(\"astropy_tests\", \"__init__.py\"), \"w\") as f:\n    f.write(\"#\")\n\n# Remove test file that tries to import all sub-packages at collection time\nos.remove(\n    os.path.join(\"astropy_tests\", \"utils\", \"iers\", \"tests\", \"test_leap_second.py\")\n)\n\n# Remove convolution tests for now as there are issues with the loading of the C extension.\n# FIXME: one way to fix this would be to migrate the convolution C extension away from using\n# ctypes and using the regular extension mechanism instead.\nshutil.rmtree(os.path.join(\"astropy_tests\", \"convolution\"))\nos.remove(os.path.join(\"astropy_tests\", \"modeling\", \"tests\", \"test_convolution.py\"))\nos.remove(os.path.join(\"astropy_tests\", \"modeling\", \"tests\", \"test_core.py\"))\nos.remove(os.path.join(\"astropy_tests\", \"visualization\", \"tests\", \"test_lupton_rgb.py\"))\n\n# FIXME: PIL minversion check does not work\nos.remove(\n    os.path.join(\"astropy_tests\", \"visualization\", \"wcsaxes\", \"tests\", \"test_misc.py\")\n)\nos.remove(\n    os.path.join(\"astropy_tests\", \"visualization\", \"wcsaxes\", \"tests\", \"test_wcsapi.py\")\n)\n\n# FIXME: The following tests rely on the fully qualified name of classes which\n# don't seem to be the same.", "metadata": {"file_name": ".pyinstaller/run_astropy_tests.py", "File Name": ".pyinstaller/run_astropy_tests.py"}}, {"code": "\"\"\"\n\n################################################################################\n# Import the required Astropy packages:\n\nimport astropy.coordinates as coord\nimport astropy.units as u\n\n################################################################################\n# Use the latest convention for the Galactocentric coordinates\ncoord.galactocentric_frame_defaults.set('latest')\n\n################################################################################\n# For this example, let's work with the coordinates and barycentric radial\n# velocity of the star HD 155967, as obtained from\n# `Simbad <https://simbad.unistra.fr/simbad/>`_:\nicrs = coord.SkyCoord(ra=258.58356362*u.deg, dec=14.55255619*u.deg,\n                      radial_velocity=-16.1*u.km/u.s, frame='icrs')\n\n################################################################################\n# We next need to decide on the velocity of the Sun in the assumed GSR frame.\n# We'll use the same velocity vector as used in the\n# `~astropy.coordinates.Galactocentric` frame, and convert it to a\n# `~astropy.coordinates.CartesianRepresentation` object using the\n# ``.to_cartesian()`` method of the\n# `~astropy.coordinates.CartesianDifferential` object ``galcen_v_sun``:\nv_sun = coord.Galactocentric().galcen_v_sun.to_cartesian()\n\n################################################################################\n# We now need to get a unit vector in the assumed Galactic frame from the sky\n# position in the ICRS frame above. We'll use this unit vector to project the\n# solar velocity onto the line-of-sight:\ngal = icrs.transform_to(coord.Galactic)\ncart_data = gal.data.to_cartesian()\nunit_vector = cart_data / cart_data.norm()\n\n################################################################################\n# Now we project the solar velocity using this unit vector:\nv_proj = v_sun.dot(unit_vector)\n\n################################################################################\n# Finally, we add the projection of the solar velocity to the radial velocity\n# to get a GSR radial velocity:\nrv_gsr = icrs.radial_velocity + v_proj\nprint(rv_gsr)", "metadata": {"file_name": "examples/coordinates/rv-to-gsr.py", "File Name": "examples/coordinates/rv-to-gsr.py", "Functions": "rv_to_gsr"}}, {"code": "\"\"\"\n==================\nEdit a FITS header\n==================\n\nThis example describes how to edit a value in a FITS header\nusing `astropy.io.fits`.\n\n\n*By: Adrian Price-Whelan*\n\n*License: BSD*\n\n\n\"\"\"\n\nfrom astropy.io import fits\nfrom astropy.utils.data import get_pkg_data_filename\n\n##############################################################################\n# Download a FITS file:\n\nfits_file = get_pkg_data_filename('tutorials/FITS-Header/input_file.fits')\n\n##############################################################################\n# Look at contents of the FITS file\n\nfits.info(fits_file)\n\n##############################################################################\n# Look at the headers of the two extensions:\n\nprint(\"Before modifications:\")\nprint()\nprint(\"Extension 0:\")\nprint(repr(fits.getheader(fits_file, 0)))\nprint()\nprint(\"Extension 1:\")\nprint(repr(fits.getheader(fits_file, 1)))\n\n##############################################################################\n# `astropy.io.fits` provides an object-oriented interface for reading and\n# interacting with FITS files, but for small operations (like this example) it\n# is often easier to use the\n# `convenience functions <https://docs.astropy.org/en/latest/io/fits/index.html#convenience-functions>`_.\n#\n# To edit a single header value in the header for extension 0, use the\n# `~astropy.io.fits.setval()` function. For example, set the OBJECT keyword\n# to 'M31':\n\nfits.setval(fits_file, 'OBJECT', value='M31')\n\n##############################################################################\n# With no extra arguments, this will modify the header for extension 0, but\n# this can be changed using the ``ext`` keyword argument. For example, we can\n# specify extension 1 instead:\n\nfits.setval(fits_file, 'OBJECT', value='M31', ext=1)\n\n##############################################################################\n# This can also be used to create a new keyword-value pair (\"card\" in FITS\n# lingo):\n\nfits.setval(fits_file, 'ANEWKEY', value='some value')\n\n##############################################################################\n# Again, this is useful for one-off modifications, but can be inefficient\n# for operations like editing multiple headers in the same file\n# because `~astropy.io.fits.setval()` loads the whole file each time it\n# is called.", "metadata": {"file_name": "examples/io/modify-fits-header.py", "File Name": "examples/io/modify-fits-header.py"}}, {"code": "class Sagittarius(coord.BaseCoordinateFrame):\n    \"\"\"\n    A Heliocentric spherical coordinate system defined by the orbit\n    of the Sagittarius dwarf galaxy, as described in\n        https://ui.adsabs.harvard.edu/abs/2003ApJ...599.1082M\n    and further explained in\n        https://www.stsci.edu/~dlaw/Sgr/.\n\n    Parameters\n    ----------\n    representation : `~astropy.coordinates.BaseRepresentation` or None\n        A representation object or None to have no data (or use the other keywords)\n    Lambda : `~astropy.coordinates.Angle`, optional, must be keyword\n        The longitude-like angle corresponding to Sagittarius' orbit.\n    Beta : `~astropy.coordinates.Angle`, optional, must be keyword\n        The latitude-like angle corresponding to Sagittarius' orbit.\n    distance : `~astropy.units.Quantity`, optional, must be keyword\n        The Distance for this object along the line-of-sight.\n    pm_Lambda_cosBeta : `~astropy.units.Quantity`, optional, must be keyword\n        The proper motion along the stream in ``Lambda`` (including the\n        ``cos(Beta)`` factor) for this object (``pm_Beta`` must also be given).\n    pm_Beta : `~astropy.units.Quantity`, optional, must be keyword\n        The proper motion in Declination for this object (``pm_ra_cosdec`` must\n        also be given).\n    radial_velocity : `~astropy.units.Quantity`, optional, keyword-only\n        The radial velocity of this object.\n\n    \"\"\"\n\n    default_representation = coord.SphericalRepresentation\n    default_differential = coord.SphericalCosLatDifferential\n\n    frame_specific_representation_info = {\n        coord.SphericalRepresentation: [\n            coord.RepresentationMapping('lon', 'Lambda'),\n            coord.RepresentationMapping('lat', 'Beta'),\n            coord.RepresentationMapping('distance', 'distance')]\n    }", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "# Define the astropy.wcs.WCS object using a Python dictionary as input\n\nimport astropy.wcs\n\nwcs_dict = {\n'CTYPE1': 'WAVE    ', 'CUNIT1': 'Angstrom', 'CDELT1': 0.2, 'CRPIX1': 0, 'CRVAL1': 10, 'NAXIS1': 5,\n'CTYPE2': 'HPLT-TAN', 'CUNIT2': 'deg', 'CDELT2': 0.5, 'CRPIX2': 2, 'CRVAL2': 0.5, 'NAXIS2': 4,\n'CTYPE3': 'HPLN-TAN', 'CUNIT3': 'deg', 'CDELT3': 0.4, 'CRPIX3': 2, 'CRVAL3': 1, 'NAXIS3': 3}\ninput_wcs = astropy.wcs.WCS(wcs_dict)", "metadata": {"file_name": "docs/wcs/examples/cube_wcs.py", "File Name": "docs/wcs/examples/cube_wcs.py"}}, {"code": "\"\"\"\n=====================================================================\nAccessing data stored as a table in a multi-extension FITS (MEF) file\n=====================================================================\n\nFITS files can often contain large amount of multi-dimensional data and\ntables. This example opens a FITS file with information\nfrom Chandra's HETG-S instrument.\n\nThe example uses `astropy.utils.data` to download multi-extension FITS (MEF)\nfile, `astropy.io.fits` to investigate the header, and\n`astropy.table.Table` to explore the data.\n\n\n*By: Lia Corrales, Adrian Price-Whelan, and Kelle Cruz*\n\n*License: BSD*\n\n\n\"\"\"\n\n##############################################################################\n# Use `astropy.utils.data` subpackage to download the FITS file used in this\n# example. Also import `~astropy.table.Table` from the `astropy.table` subpackage\n# and `astropy.io.fits`\n\nfrom astropy.io import fits\nfrom astropy.table import Table\nfrom astropy.utils.data import get_pkg_data_filename\n\n##############################################################################\n# Download a FITS file\n\nevent_filename = get_pkg_data_filename('tutorials/FITS-tables/chandra_events.fits')\n\n##############################################################################\n# Display information about the contents of the FITS file.\n\nfits.info(event_filename)\n\n##############################################################################\n# Extension 1, EVENTS, is a Table that contains information about each X-ray\n# photon that hit Chandra's HETG-S detector.\n#\n# Use `~astropy.table.Table` to read the table\n\nevents = Table.read(event_filename, hdu=1)\n\n##############################################################################\n# Print the column names of the Events Table.\n\nprint(events.columns)\n\n##############################################################################\n# If a column contains unit information, it will have an associated\n# `astropy.units` object.\n\nprint(events['energy'].unit)\n\n##############################################################################\n# Print the data stored in the Energy column.\n\nprint(events['energy'])", "metadata": {"file_name": "examples/io/fits-tables.py", "File Name": "examples/io/fits-tables.py"}}, {"code": "\"\"\"\n========================================================================\nTransforming positions and velocities to and from a Galactocentric frame\n========================================================================\n\nThis document shows a few examples of how to use and customize the\n`~astropy.coordinates.Galactocentric` frame to transform Heliocentric sky\npositions, distance, proper motions, and radial velocities to a Galactocentric,\nCartesian frame, and the same in reverse.\n\nThe main configurable parameters of the `~astropy.coordinates.Galactocentric`\nframe control the position and velocity of the solar system barycenter within\nthe Galaxy. These are specified by setting the ICRS coordinates of the\nGalactic center, the distance to the Galactic center (the sun-galactic center\nline is always assumed to be the x-axis of the Galactocentric frame), and the\nCartesian 3-velocity of the sun in the Galactocentric frame. We'll first\ndemonstrate how to customize these values, then show how to set the solar motion\ninstead by inputting the proper motion of Sgr A*.\n\nNote that, for brevity, we may refer to the solar system barycenter as just \"the\nsun\" in the examples below.\n\n\n*By: Adrian Price-Whelan*\n\n*License: BSD*\n\n\n\"\"\"\n\n##############################################################################\n# Make `print` work the same in all versions of Python, set up numpy,\n# matplotlib, and use a nicer set of plot parameters:\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom astropy.visualization import astropy_mpl_style\n\nplt.style.use(astropy_mpl_style)\n\n\n##############################################################################\n# Import the necessary astropy subpackages\n\nimport astropy.coordinates as coord\nimport astropy.units as u\n\n##############################################################################\n# Let's first define a barycentric coordinate and velocity in the ICRS frame.", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(\"index\", project.lower(), project + \" Documentation\", [author], 1)]\n\n# Setting this URL is requited by sphinx-astropy\ngithub_issues_url = \"https://github.com/astropy/astropy/issues/\"\nedit_on_github_branch = \"main\"\n\n# Enable nitpicky mode - which ensures that all references in the docs\n# resolve.\n\nnitpicky = True\n# See docs/nitpick-exceptions file for the actual listing.\nnitpick_ignore = []\nfor line in open(\"nitpick-exceptions\"):\n    if line.strip() == \"\" or line.startswith(\"#\"):\n        continue\n    dtype, target = line.split(None, 1)\n    nitpick_ignore.append((dtype, target.strip()))\n\n# -- Options for the Sphinx gallery -------------------------------------------\n\ntry:\n    import warnings\n\n    import sphinx_gallery\n\n    extensions += [\"sphinx_gallery.gen_gallery\"]\n\n    sphinx_gallery_conf = {\n        \"backreferences_dir\": \"generated/modules\",  # path to store the module using example template\n        \"filename_pattern\": \"^((?!skip_).)*$\",  # execute all examples except those that start with \"skip_\"\n        \"examples_dirs\": f\"..{os.sep}examples\",  # path to the examples scripts\n        \"gallery_dirs\": \"generated/examples\",  # path to save gallery generated examples\n        \"reference_url\": {\n            \"astropy\": None,\n            \"matplotlib\": \"https://matplotlib.org/stable/\",\n            \"numpy\": \"https://numpy.org/doc/stable/\",\n        },\n        \"abort_on_example_error\": True,\n    }\n\n    # Filter out backend-related warnings as described in\n    # https://github.com/sphinx-gallery/sphinx-gallery/pull/564\n    warnings.filterwarnings(\n        \"ignore\",\n        category=UserWarning,\n        message=(\n            \"Matplotlib is currently using agg, which is a\"\n            \" non-GUI backend, so cannot show the figure.\"\n        ),\n    )\n\nexcept ImportError:\n    sphinx_gallery = None", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "##############################################################################\n# Do the same with `~astropy.coordinates.get_body` to find when the moon is\n# up. Be aware that this will need to download a 10MB file from the internet\n# to get a precise location of the moon.\n\nfrom astropy.coordinates import get_body\n\nmoon_July12_to_13 = get_body(\"moon\", times_July12_to_13)\nmoonaltazs_July12_to_13 = moon_July12_to_13.transform_to(frame_July12_to_13)\n\n##############################################################################\n# Find the alt,az coordinates of M33 at those same times:\n\nm33altazs_July12_to_13 = m33.transform_to(frame_July12_to_13)\n\n##############################################################################\n# Make a beautiful figure illustrating nighttime and the altitudes of M33 and\n# the Sun over that time:\n\nplt.plot(delta_midnight, sunaltazs_July12_to_13.alt, color='r', label='Sun')\nplt.plot(delta_midnight, moonaltazs_July12_to_13.alt, color=[0.75]*3, ls='--', label='Moon')\nplt.scatter(delta_midnight, m33altazs_July12_to_13.alt,\n            c=m33altazs_July12_to_13.az, label='M33', lw=0, s=8,\n            cmap='viridis')\nplt.fill_between(delta_midnight, 0*u.deg, 90*u.deg,\n                 sunaltazs_July12_to_13.alt < -0*u.deg, color='0.5', zorder=0)\nplt.fill_between(delta_midnight, 0*u.deg, 90*u.deg,\n                 sunaltazs_July12_to_13.alt < -18*u.deg, color='k', zorder=0)\nplt.colorbar().set_label('Azimuth [deg]')\nplt.legend(loc='upper left')\nplt.xlim(-12*u.hour, 12*u.hour)\nplt.xticks((np.arange(13)*2-12)*u.hour)\nplt.ylim(0*u.deg, 90*u.deg)\nplt.xlabel('Hours from EDT Midnight')\nplt.ylabel('Altitude [deg]')\nplt.show()", "metadata": {"file_name": "examples/coordinates/plot_obs-planning.py", "File Name": "examples/coordinates/plot_obs-planning.py"}}, {"code": "x = 0\ny = 0\norigin = 0\nassert (w.wcs_pix2world(x, y, origin) ==\n        w.wcs_pix2world(x + 1, y + 1, origin + 1))\n\n# Now, write out the WCS object as a FITS header\nheader = w.to_header()\n\n# header is an astropy.io.fits.Header object.  We can use it to create a new\n# PrimaryHDU and write it to a file.\nhdu = fits.PrimaryHDU(header=header)\n# Save to FITS file\n# hdu.writeto('test.fits')", "metadata": {"file_name": "docs/wcs/examples/programmatic.py", "File Name": "docs/wcs/examples/programmatic.py"}}, {"code": "def setup(app):\n    if sphinx_gallery is None:\n        msg = (\n            \"The sphinx_gallery extension is not installed, so the \"\n            \"gallery will not be built.  You will probably see \"\n            \"additional warnings about undefined references due \"\n            \"to this.\"\n        )\n        try:\n            app.warn(msg)\n        except AttributeError:\n            # Sphinx 1.6+\n            from sphinx.util import logging\n\n            logger = logging.getLogger(__name__)\n            logger.warning(msg)\n\n    # Generate the page from Jinja template\n    app.connect(\"source-read\", rstjinja)\n    # Set this to higher priority than intersphinx; this way when building\n    # dev docs astropy-dev: targets will go to the local docs instead of the\n    # intersphinx mapping\n    app.connect(\"missing-reference\", resolve_astropy_and_dev_reference, priority=400)", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "Here are\n# the positions and velocities of the rings; note that in the velocity plot,\n# the velocities of the 4 rings are identical and thus overlaid under the same\n# curve:\nfig,axes = plt.subplots(1, 2, figsize=(12,6))\n\n# Positions\naxes[0].plot(gc_rings.x.T, gc_rings.y.T, marker='None', linewidth=3)\naxes[0].text(-8., 0, r'$\\odot$', fontsize=20)\n\naxes[0].set_xlim(-30, 30)\naxes[0].set_ylim(-30, 30)\n\naxes[0].set_xlabel('$x$ [kpc]')\naxes[0].set_ylabel('$y$ [kpc]')\n\n# Velocities\naxes[1].plot(gc_rings.v_x.T, gc_rings.v_y.T, marker='None', linewidth=3)\n\naxes[1].set_xlim(-250, 250)\naxes[1].set_ylim(-250, 250)\n\naxes[1].set_xlabel(f\"$v_x$ [{(u.km / u.s).to_string('latex_inline')}]\")\naxes[1].set_ylabel(f\"$v_y$ [{(u.km / u.s).to_string('latex_inline')}]\")\n\nfig.tight_layout()\n\nplt.show()\n\n##############################################################################\n# Now we can transform to Galactic coordinates and visualize the rings in\n# observable coordinates:\ngal_rings = gc_rings.transform_to(coord.Galactic)\n\nfig, ax = plt.subplots(1, 1, figsize=(8, 6))\nfor i in range(len(ring_distances)):\n    ax.plot(gal_rings[i].l.degree, gal_rings[i].pm_l_cosb.value,\n            label=str(ring_distances[i]), marker='None', linewidth=3)\n\nax.set_xlim(360, 0)\n\nax.set_xlabel('$l$ [deg]')\nax.set_ylabel(fr'$\\mu_l \\, \\cos b$ [{(u.mas/u.yr).to_string(\"latex_inline\")}]')\n\nax.legend()\n\nplt.show()", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "#\n# Get the coordinates of M33:\n\nm33 = SkyCoord.from_name('M33')\n\n##############################################################################\n# Use `astropy.coordinates.EarthLocation` to provide the location of Bear\n# Mountain and set the time to 11pm EDT on 2012 July 12:\n\nbear_mountain = EarthLocation(lat=41.3*u.deg, lon=-74*u.deg, height=390*u.m)\nutcoffset = -4*u.hour  # Eastern Daylight Time\ntime = Time('2012-7-12 23:00:00') - utcoffset\n\n##############################################################################\n# `astropy.coordinates.EarthLocation.get_site_names` and\n# `~astropy.coordinates.EarthLocation.get_site_names` can be used to get\n# locations of major observatories.\n#\n# Use `astropy.coordinates` to find the Alt, Az coordinates of M33 at as\n# observed from Bear Mountain at 11pm on 2012 July 12.\n\nm33altaz = m33.transform_to(AltAz(obstime=time,location=bear_mountain))\nprint(f\"M33's Altitude = {m33altaz.alt:.2}\")\n\n##############################################################################\n# This is helpful since it turns out M33 is barely above the horizon at this\n# time. It's more informative to find M33's airmass over the course of\n# the night.", "metadata": {"file_name": "examples/coordinates/plot_obs-planning.py", "File Name": "examples/coordinates/plot_obs-planning.py"}}, {"code": "# We'll use the data for the star HD 39881 from the `Simbad\n# <https://simbad.unistra.fr/simbad/>`_ database:\n\nc1 = coord.SkyCoord(ra=89.014303*u.degree, dec=13.924912*u.degree,\n                    distance=(37.59*u.mas).to(u.pc, u.parallax()),\n                    pm_ra_cosdec=372.72*u.mas/u.yr,\n                    pm_dec=-483.69*u.mas/u.yr,\n                    radial_velocity=0.37*u.km/u.s,\n                    frame='icrs')\n\n##############################################################################\n# This is a high proper-motion star; suppose we'd like to transform its position\n# and velocity to a Galactocentric frame to see if it has a large 3D velocity\n# as well. To use the Astropy default solar position and motion parameters, we\n# can simply do:\n\ngc1 = c1.transform_to(coord.Galactocentric)\n\n##############################################################################\n# From here, we can access the components of the resulting\n# `~astropy.coordinates.Galactocentric` instance to see the 3D Cartesian\n# velocity components:\n\nprint(gc1.v_x, gc1.v_y, gc1.v_z)\n\n##############################################################################\n# The default parameters for the `~astropy.coordinates.Galactocentric` frame\n# are detailed in the linked documentation, but we can modify the most commonly\n# changes values using the keywords ``galcen_distance``, ``galcen_v_sun``, and\n# ``z_sun`` which set the sun-Galactic center distance, the 3D velocity vector\n# of the sun, and the height of the sun above the Galactic midplane,\n# respectively. The velocity of the sun can be specified as an\n# `~astropy.units.Quantity` object with velocity units and is interpreted as a\n# Cartesian velocity, as in the example below.", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "\"\"\"\n=======================================\nRead and plot an image from a FITS file\n=======================================\n\nThis example opens an image stored in a FITS file and displays it to the screen.\n\nThis example uses `astropy.utils.data` to download the file, `astropy.io.fits` to open\nthe file, and `matplotlib.pyplot` to display the image.\n\n\n*By: Lia R. Corrales, Adrian Price-Whelan, Kelle Cruz*\n\n*License: BSD*\n\n\n\"\"\"\n\n##############################################################################\n# Set up matplotlib and use a nicer set of plot parameters\n\nimport matplotlib.pyplot as plt\n\nfrom astropy.visualization import astropy_mpl_style\n\nplt.style.use(astropy_mpl_style)\n\n##############################################################################\n# Download the example FITS files used by this example:\n\nfrom astropy.io import fits\nfrom astropy.utils.data import get_pkg_data_filename\n\nimage_file = get_pkg_data_filename('tutorials/FITS-images/HorseHead.fits')\n\n##############################################################################\n# Use `astropy.io.fits.info()` to display the structure of the file:\n\nfits.info(image_file)\n\n##############################################################################\n# Generally the image information is located in the Primary HDU, also known\n# as extension 0. Here, we use `astropy.io.fits.getdata()` to read the image\n# data from this first extension using the keyword argument ``ext=0``:\n\nimage_data = fits.getdata(image_file, ext=0)\n\n##############################################################################\n# The data is now stored as a 2D numpy array. Print the dimensions using the\n# shape attribute:\n\nprint(image_data.shape)\n\n##############################################################################\n# Display the image data:\n\nplt.figure()\nplt.imshow(image_data, cmap='gray')\nplt.colorbar()", "metadata": {"file_name": "examples/io/plot_fits-image.py", "File Name": "examples/io/plot_fits-image.py"}}, {"code": "r\"\"\"\n==========================================================\nCreate a new coordinate class (for the Sagittarius stream)\n==========================================================\n\nThis document describes in detail how to subclass and define a custom spherical\ncoordinate frame, as discussed in :ref:`astropy:astropy-coordinates-design` and\nthe docstring for `~astropy.coordinates.BaseCoordinateFrame`. In this example,\nwe will define a coordinate system defined by the plane of orbit of the\nSagittarius Dwarf Galaxy (hereafter Sgr; as defined in Majewski et al. 2003).\nThe Sgr coordinate system is often referred to in terms of two angular\ncoordinates, :math:`\\Lambda,B`.\n\nTo do this, we need to define a subclass of\n`~astropy.coordinates.BaseCoordinateFrame` that knows the names and units of the\ncoordinate system angles in each of the supported representations.  In this case\nwe support `~astropy.coordinates.SphericalRepresentation` with \"Lambda\" and\n\"Beta\". Then we have to define the transformation from this coordinate system to\nsome other built-in system. Here we will use Galactic coordinates, represented\nby the `~astropy.coordinates.Galactic` class.\n\nSee Also\n--------\n* The `gala package <http://gala.adrian.pw/>`_, which defines a number of\n  Astropy coordinate frames for stellar stream coordinate systems.\n* Majewski et al. 2003, \"A Two Micron All Sky Survey View of the Sagittarius\n  Dwarf Galaxy. I. Morphology of the Sagittarius Core and Tidal Arms\",\n  https://arxiv.org/abs/astro-ph/0304198\n* Law & Majewski 2010, \"The Sagittarius Dwarf Galaxy: A Model for Evolution in a\n  Triaxial Milky Way Halo\", https://arxiv.org/abs/1003.1132\n* David Law's Sgr info page https://www.stsci.edu/~dlaw/Sgr/\n\n\n*By: Adrian Price-Whelan, Erik Tollerud*\n\n*License: BSD*", "metadata": {"file_name": "examples/coordinates/plot_sgr-coordinate-frame.py", "File Name": "examples/coordinates/plot_sgr-coordinate-frame.py", "Classes": "Sagittarius", "Functions": "galactic_to_sgr, sgr_to_galactic"}}, {"code": "# Load the WCS information from a fits header, and use it\n# to convert pixel coordinates to world coordinates.\n\nimport sys\n\nimport numpy as np\n\nfrom astropy import wcs\nfrom astropy.io import fits", "metadata": {"file_name": "docs/wcs/examples/from_file.py", "File Name": "docs/wcs/examples/from_file.py", "Functions": "load_wcs_from_file"}}, {"code": "def resolve_astropy_and_dev_reference(app, env, node, contnode):\n    \"\"\"\n    Reference targets for ``astropy:`` and ``astropy-dev:`` are special cases.\n\n    Documentation links in astropy can be set up as intersphinx links so that\n    affiliate packages do not have to override the docstrings when building\n    the docs.\n\n    If we are building the development docs it is a local ref targeting the\n    label ``astropy-dev:<label>``, but for stable docs it should be an\n    intersphinx resolution to the development docs.\n\n    See https://github.com/astropy/astropy/issues/11366\n    \"\"\"\n    # should the node be processed?\n    reftarget = node.get(\"reftarget\")  # str or None\n    if str(reftarget).startswith(\"astropy:\"):\n        # This allows Astropy to use intersphinx links to itself and have\n        # them resolve to local links. Downstream packages will see intersphinx.\n        # TODO! deprecate this if sphinx-doc/sphinx/issues/9169 is implemented.\n        process, replace = True, \"astropy:\"\n    elif dev and str(reftarget).startswith(\"astropy-dev:\"):\n        process, replace = True, \"astropy-dev:\"\n    else:\n        process, replace = False, \"\"\n\n    # make link local\n    if process:\n        reftype = node.get(\"reftype\")\n        refdoc = node.get(\"refdoc\", app.env.docname)\n        # convert astropy intersphinx targets to local links.\n        # there are a few types of intersphinx link patterns, as described in\n        # https://docs.readthedocs.io/en/stable/guides/intersphinx.html\n        reftarget = reftarget.replace(replace, \"\")\n        if reftype == \"doc\":  # also need to replace the doc link\n            node.replace_attr(\"reftarget\", reftarget)\n        # Delegate to the ref node's original domain/target (typically :ref:)\n        try:\n            domain = app.env.domains[node[\"refdomain\"]]\n            return domain.resolve_xref(\n                app.env, refdoc, app.builder, reftype, reftarget, node, contnode\n            )\n        except Exception:\n            pass\n\n        # Otherwise return None which should delegate to intersphinx", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "As\n# an example, we'll generate 4 theoretical circular orbits at different\n# Galactocentric radii with the same circular velocity, and transform them to\n# Heliocentric coordinates:\n\nring_distances = np.arange(10, 25+1, 5) * u.kpc\ncirc_velocity = 220 * u.km/u.s\n\nphi_grid = np.linspace(90, 270, 512) * u.degree # grid of azimuths\nring_rep = coord.CylindricalRepresentation(\n    rho=ring_distances[:,np.newaxis],\n    phi=phi_grid[np.newaxis],\n    z=np.zeros_like(ring_distances)[:,np.newaxis])\n\nangular_velocity = (-circ_velocity / ring_distances).to(u.mas/u.yr,\n                                                        u.dimensionless_angles())\nring_dif = coord.CylindricalDifferential(\n    d_rho=np.zeros(phi_grid.shape)[np.newaxis]*u.km/u.s,\n    d_phi=angular_velocity[:,np.newaxis],\n    d_z=np.zeros(phi_grid.shape)[np.newaxis]*u.km/u.s\n)\n\nring_rep = ring_rep.with_differentials(ring_dif)\ngc_rings = coord.SkyCoord(ring_rep, frame=coord.Galactocentric)\n\n##############################################################################\n# First, let's visualize the geometry in Galactocentric coordinates.", "metadata": {"file_name": "examples/coordinates/plot_galactocentric-frame.py", "File Name": "examples/coordinates/plot_galactocentric-frame.py"}}, {"code": "import configparser\nimport doctest\nimport os\nimport sys\nfrom datetime import datetime\nfrom importlib import metadata\n\nfrom packaging.requirements import Requirement\nfrom packaging.specifiers import SpecifierSet\n\n# -- Check for missing dependencies -------------------------------------------\nmissing_requirements = {}\nfor line in metadata.requires(\"astropy\"):\n    if 'extra == \"docs\"' in line:\n        req = Requirement(line.split(\";\")[0])\n        req_package = req.name.lower()\n        req_specifier = str(req.specifier)\n\n        try:\n            version = metadata.version(req_package)\n        except metadata.PackageNotFoundError:\n            missing_requirements[req_package] = req_specifier\n\n        if version not in SpecifierSet(req_specifier, prereleases=True):\n            missing_requirements[req_package] = req_specifier\n\nif missing_requirements:\n    print(\n        \"The following packages could not be found and are required to \"\n        \"build the documentation:\"\n    )\n    for key, val in missing_requirements.items():\n        print(f\"    * {key} {val}\")\n    print('Please install the \"docs\" requirements.')\n    sys.exit(1)\n\nfrom sphinx_astropy.conf.v1 import *  # noqa: E402\nfrom sphinx_astropy.conf.v1 import (  # noqa: E402\n    exclude_patterns,\n    extensions,\n    intersphinx_mapping,\n    numpydoc_xref_aliases,\n    numpydoc_xref_astropy_aliases,\n    numpydoc_xref_ignore,\n    rst_epilog,\n)\n\n# -- Plot configuration -------------------------------------------------------\nplot_rcparams = {\n    \"axes.labelsize\": \"large\",\n    \"figure.figsize\": (6, 6),\n    \"figure.subplot.hspace\": 0.5,\n    \"savefig.bbox\": \"tight\",\n    \"savefig.facecolor\": \"none\",\n}\nplot_apply_rcparams = True\nplot_html_show_source_link = False\nplot_formats = [\"png\", \"svg\", \"pdf\"]\n# Don't use the default - which includes a numpy and matplotlib import\nplot_pre_code = \"\"\n\n# -- General configuration ----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = \"3.0\"\n\n# The intersphinx_mapping in sphinx_astropy.sphinx refers to astropy for\n# the benefit of other packages who want to refer to objects in the\n# astropy core.", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "\"\"\"\n================================================================\nConvert a radial velocity to the Galactic Standard of Rest (GSR)\n================================================================\n\nRadial or line-of-sight velocities of sources are often reported in a\nHeliocentric or Solar-system barycentric reference frame. A common\ntransformation incorporates the projection of the Sun's motion along the\nline-of-sight to the target, hence transforming it to a Galactic rest frame\ninstead (sometimes referred to as the Galactic Standard of Rest, GSR). This\ntransformation depends on the assumptions about the orientation of the Galactic\nframe relative to the bary- or Heliocentric frame. It also depends on the\nassumed solar velocity vector. Here we'll demonstrate how to perform this\ntransformation using a sky position and barycentric radial-velocity.\n\n\n*By: Adrian Price-Whelan*\n\n*License: BSD*", "metadata": {"file_name": "examples/coordinates/rv-to-gsr.py", "File Name": "examples/coordinates/rv-to-gsr.py", "Functions": "rv_to_gsr"}}, {"code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n\n# This file needs to be included here to make sure commands such\n# as ``pytest docs/...`` works, since this\n# will ignore the conftest.py file at the root of the repository\n# and the one in astropy/conftest.py\n\nimport os\nimport tempfile\n\nimport pytest\n\n# Make sure we use temporary directories for the config and cache\n# so that the tests are insensitive to local configuration.\n\nos.environ[\"XDG_CONFIG_HOME\"] = tempfile.mkdtemp(\"astropy_config\")\nos.environ[\"XDG_CACHE_HOME\"] = tempfile.mkdtemp(\"astropy_cache\")\n\nos.mkdir(os.path.join(os.environ[\"XDG_CONFIG_HOME\"], \"astropy\"))\nos.mkdir(os.path.join(os.environ[\"XDG_CACHE_HOME\"], \"astropy\"))\n\n# Note that we don't need to change the environment variables back or remove\n# them after testing, because they are only changed for the duration of the\n# Python process, and this configuration only matters if running pytest\n# directly, not from e.g. an IPython session.\n\n\n@pytest.fixture(autouse=True)\ndef _docdir(request):\n    \"\"\"Run doctests in isolated tmp_path so outputs do not end up in repo.\"\"\"\n    # Trigger ONLY for doctestplus\n    doctest_plugin = request.config.pluginmanager.getplugin(\"doctestplus\")\n    if isinstance(request.node.parent, doctest_plugin._doctest_textfile_item_cls):\n        # Don't apply this fixture to io.rst.  It reads files and doesn't write.\n        # Implementation from https://github.com/pytest-dev/pytest/discussions/10437\n        if \"io.rst\" not in request.node.name:\n            old_cwd = os.getcwd()\n            tmp_path = request.getfixturevalue(\"tmp_path\")\n            os.chdir(tmp_path)\n            yield\n            os.chdir(old_cwd)\n        else:\n            yield\n    else:\n        yield", "metadata": {"file_name": "docs/conftest.py", "File Name": "docs/conftest.py", "Functions": "_docdir"}}, {"code": "# Licensed under a 3-clause BSD style license - see LICENSE.rst\n#\n# Astropy documentation build configuration file.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this file.\n#\n# All configuration values have a default. Some values are defined in\n# the global Astropy configuration which is loaded here before anything else.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n# sys.path.insert(0, os.path.abspath('..'))\n# IMPORTANT: the above commented section was generated by sphinx-quickstart, but\n# is *NOT* appropriate for astropy or Astropy affiliated packages. It is left\n# commented out with this explanation to make it clear why this should not be\n# done. If the sys.path entry above is added, when the astropy.sphinx.conf\n# import occurs, it will import the *source* version of astropy instead of the\n# version installed (if invoked as \"make html\" or directly with sphinx), or the\n# version in the build directory.\n# Thus, any C-extensions that are needed to build the documentation will *not*\n# be accessible, and the documentation will not build correctly.\n# See sphinx_astropy.conf for which values are set there.", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "# -- Options for HTML output ---------------------------------------------------\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\nhtml_title = f\"{project} v{release}\"\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = project + \"doc\"\n\n# A dictionary of values to pass into the template engine's context for all pages.\nhtml_context = {\"to_be_indexed\": [\"stable\", \"latest\"], \"is_development\": dev}\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\nhtml_extra_path = [\"robots.txt\"]\n\n# -- Options for LaTeX output --------------------------------------------------\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    (\"index\", project + \".tex\", project + \" Documentation\", author, \"manual\")\n]\n\nlatex_logo = \"_static/astropy_logo.pdf\"", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "To make several modifications, it's better to load the file once:\n\nwith fits.open(fits_file, 'update') as f:\n    for hdu in f:\n        hdu.header['OBJECT'] = 'CAT'\n\nprint(\"After modifications:\")\nprint()\nprint(\"Extension 0:\")\nprint(repr(fits.getheader(fits_file, 0)))\nprint()\nprint(\"Extension 1:\")\nprint(repr(fits.getheader(fits_file, 1)))", "metadata": {"file_name": "examples/io/modify-fits-header.py", "File Name": "examples/io/modify-fits-header.py"}}, {"code": "# -- Options for linkcheck output -------------------------------------------\nlinkcheck_retry = 5\nlinkcheck_ignore = [\n    \"https://journals.aas.org/manuscript-preparation/\",\n    \"https://maia.usno.navy.mil/\",\n    \"https://www.usno.navy.mil/USNO/time/gps/usno-gps-time-transfer\",\n    \"https://aa.usno.navy.mil/publications/docs/Circular_179.php\",\n    \"http://data.astropy.org\",\n    \"https://doi.org/\",  # CI blocked by service provider\n    \"https://ui.adsabs.harvard.edu\",  # CI blocked by service provider\n    \"https://www.tandfonline.com/\",  # 403 Client Error: Forbidden\n    \"https://physics.nist.gov/\",  # SSL: CERTIFICATE_VERIFY_FAILED\n    \"https://ieeexplore.ieee.org/\",  # 418 Client Error: I'm a teapot\n    \"https://pyfits.readthedocs.io/en/v3.2.1/\",  # defunct page in CHANGES.rst\n    r\"https://github\\.com/astropy/astropy/(?:issues|pull)/\\d+\",\n]\nlinkcheck_timeout = 180\nlinkcheck_anchors = False\n\n\ndef rstjinja(app, docname, source):\n    \"\"\"Render pages as a jinja template to hide/show dev docs.\"\"\"\n    # Make sure we're outputting HTML\n    if app.builder.format != \"html\":\n        return\n    files_to_render = [\"index\", \"install\", \"development/index\"]\n    if docname in files_to_render:\n        print(f\"Jinja rendering {docname}\")\n        rendered = app.builder.templates.render_string(\n            source[0], app.config.html_context\n        )\n        source[0] = rendered", "metadata": {"file_name": "docs/conf.py", "File Name": "docs/conf.py", "Functions": "rstjinja, resolve_astropy_and_dev_reference, setup"}}, {"code": "# NOTE: this hook should be added to\n# https://github.com/pyinstaller/pyinstaller-hooks-contrib\n# once that repository is ready for pull requests\nfrom PyInstaller.utils.hooks import collect_data_files\n\ndatas = collect_data_files(\"skyfield\")", "metadata": {"file_name": ".pyinstaller/hooks/hook-skyfield.py", "File Name": ".pyinstaller/hooks/hook-skyfield.py"}}], "traj": {"usage": {"embedding_tokens": 0}}}
